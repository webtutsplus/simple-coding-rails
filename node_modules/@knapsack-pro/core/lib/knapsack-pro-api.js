"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KnapsackProAPI = void 0;
var axios_1 = require("axios");
var axiosRetry = require('axios-retry');
var config_1 = require("./config");
var knapsack_pro_logger_1 = require("./knapsack-pro-logger");
var KnapsackProAPI = (function () {
    function KnapsackProAPI(clientName, clientVersion) {
        this.retryCondition = this.retryCondition.bind(this);
        this.retryDelay = this.retryDelay.bind(this);
        this.knapsackProLogger = new knapsack_pro_logger_1.KnapsackProLogger();
        this.api = this.setUpApiClient(clientName, clientVersion);
    }
    KnapsackProAPI.prototype.fetchTestsFromQueue = function (allTestFiles, initializeQueue, attemptConnectToQueue) {
        var url = '/v1/queues/queue';
        var shouldSendTestFilesInPayload = initializeQueue && !attemptConnectToQueue;
        var data = __assign({ test_suite_token: config_1.KnapsackProEnvConfig.testSuiteToken, can_initialize_queue: initializeQueue, attempt_connect_to_queue: attemptConnectToQueue, fixed_queue_split: config_1.KnapsackProEnvConfig.fixedQueueSplit, commit_hash: config_1.KnapsackProEnvConfig.commitHash, branch: config_1.KnapsackProEnvConfig.branch, node_total: config_1.KnapsackProEnvConfig.ciNodeTotal, node_index: config_1.KnapsackProEnvConfig.ciNodeIndex, node_build_id: config_1.KnapsackProEnvConfig.ciNodeBuildId }, (shouldSendTestFilesInPayload && { test_files: allTestFiles }));
        return this.api.post(url, data);
    };
    KnapsackProAPI.prototype.createBuildSubset = function (recordedTestFiles) {
        var url = '/v1/build_subsets';
        var data = {
            test_suite_token: config_1.KnapsackProEnvConfig.testSuiteToken,
            commit_hash: config_1.KnapsackProEnvConfig.commitHash,
            branch: config_1.KnapsackProEnvConfig.branch,
            node_total: config_1.KnapsackProEnvConfig.ciNodeTotal,
            node_index: config_1.KnapsackProEnvConfig.ciNodeIndex,
            test_files: recordedTestFiles,
        };
        return this.api.post(url, data);
    };
    KnapsackProAPI.prototype.isExpectedErrorStatus = function (error) {
        var response = error.response;
        if (!response) {
            return false;
        }
        var status = response.status;
        return (status === 400 ||
            status === 422 ||
            status === 403);
    };
    KnapsackProAPI.prototype.setUpApiClient = function (clientName, clientVersion) {
        var _this = this;
        var apiClient = axios_1.default.create({
            baseURL: config_1.KnapsackProEnvConfig.endpoint,
            timeout: 15000,
            headers: {
                'KNAPSACK-PRO-CLIENT-NAME': clientName,
                'KNAPSACK-PRO-CLIENT-VERSION': clientVersion,
            },
        });
        axiosRetry(apiClient, {
            retries: 2,
            shouldResetTimeout: true,
            retryDelay: this.retryDelay,
            retryCondition: this.retryCondition,
        });
        apiClient.interceptors.request.use(function (config) {
            var method = config.method, baseURL = config.baseURL, url = config.url, headers = config.headers, data = config.data;
            var apiUrl = baseURL + url.replace(baseURL, '');
            var requestHeaders = knapsack_pro_logger_1.KnapsackProLogger.objectInspect(headers);
            var requestBody = knapsack_pro_logger_1.KnapsackProLogger.objectInspect(data);
            _this.knapsackProLogger.info(method.toUpperCase() + " " + apiUrl);
            _this.knapsackProLogger.debug(method.toUpperCase() + " " + apiUrl + "\n\n" +
                'Request headers:\n' +
                (requestHeaders + "\n\n") +
                'Request body:\n' +
                ("" + requestBody));
            return config;
        });
        apiClient.interceptors.response.use(function (response) {
            var status = response.status, statusText = response.statusText, data = response.data, requestId = response.headers["x-request-id"];
            var responeseBody = knapsack_pro_logger_1.KnapsackProLogger.objectInspect(data);
            _this.knapsackProLogger.info(status + " " + statusText + "\n\n" +
                'Request ID:\n' +
                (requestId + "\n\n") +
                'Response body:\n' +
                ("" + responeseBody));
            return response;
        }, function (error) {
            var response = error.response;
            if (response) {
                var status = response.status, statusText = response.statusText, data = response.data, requestId = response.headers["x-request-id"];
                var responeseBody = knapsack_pro_logger_1.KnapsackProLogger.objectInspect(data);
                _this.knapsackProLogger.error(status + " " + statusText + "\n\n" +
                    'Request ID:\n' +
                    (requestId + "\n\n") +
                    'Response error body:\n' +
                    ("" + responeseBody));
            }
            else {
                _this.knapsackProLogger.error(error);
            }
            return Promise.reject(error);
        });
        return apiClient;
    };
    KnapsackProAPI.prototype.retryCondition = function (error) {
        return (axiosRetry.isNetworkError(error) ||
            this.isRetriableRequestError(error) ||
            !this.isExpectedErrorStatus(error));
    };
    KnapsackProAPI.prototype.isRetriableRequestError = function (error) {
        if (!error.config) {
            return false;
        }
        return axiosRetry.isRetryableError(error);
    };
    KnapsackProAPI.prototype.retryDelay = function (retryCount) {
        var requestRetryTimebox = 8000;
        var delay = retryCount * requestRetryTimebox;
        var randomSum = delay * 0.2 * Math.random();
        var finalDelay = delay + randomSum;
        this.knapsackProLogger.info("(" + retryCount + ") Wait " + finalDelay + " ms and retry request to Knapsack Pro API.");
        return finalDelay;
    };
    return KnapsackProAPI;
}());
exports.KnapsackProAPI = KnapsackProAPI;
