var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable no-restricted-syntax, react/forbid-prop-types */
import React from 'react';
import PropTypes from 'prop-types';
import RAF from 'raf';

var transitionEvent = function () {
  if (typeof document === 'undefined') {
    return;
  }
  var testElement = document.createElement('fakeelement');
  var transitions = {
    transition: 'transitionend',
    OTransition: 'oTransitionEnd',
    MozTransition: 'transitionend',
    WebkitTransition: 'webkitTransitionEnd'

    /* eslint-disable no-restricted-syntax */
  };for (var t in transitions) {
    if (testElement && testElement.style && testElement.style[t] !== undefined) {
      return transitions[t];
    }
  }
}();

var easings = {
  // Cubic
  easeInCubic: 'cubic-bezier(0.550, 0.055, 0.675, 0.190)',
  easeOutCubic: 'cubic-bezier(0.215, 0.610, 0.355, 1.000)',
  easeInOutCubic: 'cubic-bezier(0.645, 0.045, 0.355, 1.000)',

  // Circ
  easeInCirc: 'cubic-bezier(0.600, 0.040, 0.980, 0.335)',
  easeOutCirc: 'cubic-bezier(0.075, 0.820, 0.165, 1.000)',
  easeInOutCirc: 'cubic-bezier(0.785, 0.135, 0.150, 0.860)',

  // Expo
  easeInExpo: 'cubic-bezier(0.950, 0.050, 0.795, 0.035)',
  easeOutExpo: 'cubic-bezier(0.190, 1.000, 0.220, 1.000)',
  easeInOutExpo: 'cubic-bezier(1.000, 0.000, 0.000, 1.000)',

  // Quad
  easeInQuad: 'cubic-bezier(0.550, 0.085, 0.680, 0.530)',
  easeOutQuad: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)',
  easeInOutQuad: 'cubic-bezier(0.455, 0.030, 0.515, 0.955)',

  // Quart
  easeInQuart: 'cubic-bezier(0.895, 0.030, 0.685, 0.220)',
  easeOutQuart: 'cubic-bezier(0.165, 0.840, 0.440, 1.000)',
  easeInOutQuart: 'cubic-bezier(0.770, 0.000, 0.175, 1.000)',

  // Quint
  easeInQuint: 'cubic-bezier(0.755, 0.050, 0.855, 0.060)',
  easeOutQuint: 'cubic-bezier(0.230, 1.000, 0.320, 1.000)',
  easeInOutQuint: 'cubic-bezier(0.860, 0.000, 0.070, 1.000)',

  // Sine
  easeInSine: 'cubic-bezier(0.470, 0.000, 0.745, 0.715)',
  easeOutSine: 'cubic-bezier(0.390, 0.575, 0.565, 1.000)',
  easeInOutSine: 'cubic-bezier(0.445, 0.050, 0.550, 0.950)',

  // Back
  easeInBack: 'cubic-bezier(0.600, -0.280, 0.735, 0.045)',
  easeOutBack: 'cubic-bezier(0.175,  0.885, 0.320, 1.275)',
  easeInOutBack: 'cubic-bezier(0.680, -0.550, 0.265, 1.550)'
};

var ReactShow = (_temp = _class = function (_React$Component) {
  _inherits(ReactShow, _React$Component);

  function ReactShow(props) {
    _classCallCheck(this, ReactShow);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.onTransitionEnd = function (e) {
      e.persist();
      if (e.target !== _this.el) {
        return;
      }
      var _this$props = _this.props,
          unmountOnHide = _this$props.unmountOnHide,
          show = _this$props.show,
          styleShow = _this$props.styleShow,
          styleHide = _this$props.styleHide;

      if (_this.state.next === 'hidden' && unmountOnHide) {
        _this.setState({
          next: false,
          mountContent: false
        });
      }
      var isAuto = _this.stylePropIsAuto('width') || _this.stylePropIsAuto('height');
      if (_this.state.next === 'auto') {
        var currentStyle = show ? _extends({}, styleShow) : _extends({}, styleHide);
        if (_this.stylePropIsAuto('width')) {
          currentStyle.width = 'auto';
        }
        if (_this.stylePropIsAuto('height')) {
          currentStyle.height = 'auto';
        }
        if (isAuto && !show) {
          currentStyle.overflow = 'hidden';
        }
        _this.setState({
          next: false,
          currentStyle: currentStyle
        });
      }
    };

    _this.animateIn = function () {
      var styleHide = _this.props.styleHide;
      var _this$state = _this.state,
          currentStyle = _this$state.currentStyle,
          mountContent = _this$state.mountContent;


      var nextStyle = mountContent ? _extends({}, currentStyle) : _extends({}, styleHide);

      if (_this.stylePropIsAuto('width') || _this.stylePropIsAuto('height')) {
        nextStyle.overflow = 'hidden';
      }

      _this.setState({
        next: 'show',
        mountContent: true,
        currentStyle: nextStyle
      });
    };

    _this.animateOut = function () {
      // If we need to animate 'auto' values, measure first
      var measurements = _this.checkNeedToMeasure() ? _this.measure() : {};
      var isAuto = _this.stylePropIsAuto('width') || _this.stylePropIsAuto('height');
      _this.setState({
        next: 'hide',
        currentStyle: _extends({}, _this.state.currentStyle, _this.stylePropIsAuto('width') ? { width: measurements.width + 'px' } : {}, _this.stylePropIsAuto('height') ? { height: measurements.height + 'px' } : {}, isAuto ? {
          overflow: 'hidden'
        } : {})
      });
    };

    _this.checkNeedToMeasure = function () {
      return _this.stylePropIsAuto('height') || _this.stylePropIsAuto('width');
    };

    _this.checkIsAuto = function () {
      return _this.stylePropIsAuto('height') && _this.el && _this.el.style.height === 'auto' || _this.stylePropIsAuto('width') && _this.el && _this.el.style.width === 'auto';
    };

    _this.handleRef = function (el) {
      _this.el = el;
    };

    _this.stylePropIsAuto = function (prop) {
      return _this.props.styleShow[prop] === 'auto';
    };

    _this.measure = function () {
      if (!_this.el) {
        return {};
      }
      return {
        width: _this.el.scrollWidth,
        height: _this.el.scrollHeight
      };
    };

    _this.makeStyles = function () {
      var _this$props2 = _this.props,
          style = _this$props2.style,
          transitionProperty = _this$props2.transitionProperty,
          duration = _this$props2.duration,
          easing = _this$props2.easing;
      var currentStyle = _this.state.currentStyle;


      var resolvedEasing = easings[easing] || easing || 'ease-out';

      return _extends({
        transitionProperty: transitionProperty,
        transitionDuration: duration + 'ms',
        transitionTimingFunction: '' + resolvedEasing
      }, style, currentStyle);
    };

    _this.state = {
      next: false,
      mountContent: props.show,
      currentStyle: props.transitionOnMount || !props.show ? props.styleHide : props.styleShow
    };
    return _this;
  }

  ReactShow.prototype.componentDidMount = function componentDidMount() {
    if (this.props.transitionOnMount && this.props.show) {
      this.animateIn();
    }
  };

  ReactShow.prototype.componentWillReceiveProps = function componentWillReceiveProps(next) {
    if (!this.props.show && next.show) {
      this.animateIn();
    } else if (this.props.show && !next.show) {
      this.animateOut();
    }
  };

  ReactShow.prototype.componentDidUpdate = function componentDidUpdate() {
    var _this2 = this;

    var _props = this.props,
        styleHide = _props.styleHide,
        styleShow = _props.styleShow;


    if (this.state.next === 'show') {
      var measurements = {};
      // Only measure if we need to
      var isAuto = this.stylePropIsAuto('width') || this.stylePropIsAuto('height');
      if (isAuto) {
        measurements = this.measure();
      }
      RAF(function () {
        _this2.setState({
          next: 'auto',
          currentStyle: _extends({}, styleShow, _this2.stylePropIsAuto('width') ? { width: measurements.width + 'px' } : {}, _this2.stylePropIsAuto('height') ? { height: measurements.height + 'px' } : {}, isAuto ? {
            overflow: 'hidden'
          } : {})
        });
      });
    }

    if (this.state.next === 'hide') {
      this.setState({
        next: false
      });
      var queueFinalHide = function queueFinalHide() {
        // If we still need to measure, delay a bit until element is ready.
        // double RAF this to be sure that the browser has painted
        RAF(function () {
          return RAF(function () {
            if (_this2.checkNeedToMeasure()) {
              if (_this2.checkIsAuto()) {
                queueFinalHide();
                return;
              }
            }

            var isAuto = _this2.stylePropIsAuto('width') || _this2.stylePropIsAuto('height');
            if (!_this2.state.next) {
              _this2.setState({
                next: 'hidden',
                currentStyle: _extends({}, styleHide, isAuto ? {
                  overflow: 'hidden'
                } : {})
              });
            }
          });
        });
      };
      queueFinalHide();
    }
  };

  ReactShow.prototype.render = function render() {
    var _props2 = this.props,
        children = _props2.children,
        originalShow = _props2.show,
        easing = _props2.easing,
        duration = _props2.duration,
        transitionProperty = _props2.transitionProperty,
        unmountOnHide = _props2.unmountOnHide,
        transitionOnMount = _props2.transitionOnMount,
        show = _props2.show,
        style = _props2.style,
        styleHide = _props2.styleHide,
        styleShow = _props2.styleShow,
        rest = _objectWithoutProperties(_props2, ['children', 'show', 'easing', 'duration', 'transitionProperty', 'unmountOnHide', 'transitionOnMount', 'show', 'style', 'styleHide', 'styleShow']);

    var mountContent = this.state.mountContent;

    return mountContent ? React.createElement(
      'div',
      _extends({
        ref: this.handleRef,
        onTransitionEnd: this.onTransitionEnd,
        style: this.makeStyles()
      }, rest),
      children
    ) : null;
  };

  return ReactShow;
}(React.Component), _class.easings = easings, _class.defaultProps = {
  show: false,
  easing: 'easeOutQuad',
  duration: 300,
  transitionProperty: 'all',
  unmountOnHide: true,
  transitionOnMount: false,
  style: {},
  styleHide: {
    height: 0
  },
  styleShow: {
    height: 'auto'
  }
}, _temp);
export { ReactShow as default };
ReactShow.propTypes = process.env.NODE_ENV !== "production" ? {
  easing: PropTypes.string,
  duration: PropTypes.number,
  transitionProperty: PropTypes.string,
  unmountOnHide: PropTypes.bool,
  style: PropTypes.object,
  styleHide: PropTypes.object,
  styleShow: PropTypes.object,
  transitionOnMount: PropTypes.bool,
  children: PropTypes.node.isRequired
} : {};