{"ast":null,"code":"function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { fetchSearch } from '../utilities/search';\nimport 'intersection-observer';\nexport function getCsrfToken() {\n  var element = document.querySelector(\"meta[name='csrf-token']\");\n  return element !== null ? element.content : undefined;\n}\n\nvar getWaitOnUserDataHandler = function getWaitOnUserDataHandler(_ref) {\n  var resolve = _ref.resolve,\n      reject = _ref.reject,\n      _ref$waitTime = _ref.waitTime,\n      waitTime = _ref$waitTime === void 0 ? 20 : _ref$waitTime;\n  var totalTimeWaiting = 0;\n  return function waitingOnUserData() {\n    if (totalTimeWaiting === 3000) {\n      reject(new Error(\"Couldn't find user data on page.\"));\n      return;\n    }\n\n    var csrfToken = getCsrfToken(document);\n    var user = document.body.dataset.user;\n\n    if (user && csrfToken !== undefined) {\n      var currentUser = JSON.parse(user);\n      resolve({\n        currentUser: currentUser,\n        csrfToken: csrfToken\n      });\n      return;\n    }\n\n    totalTimeWaiting += waitTime;\n    setTimeout(waitingOnUserData, waitTime);\n  };\n};\n\nexport var getCurrentUser = function getCurrentUser() {\n  var user = document.body.dataset.user;\n  return JSON.parse(user);\n};\nexport function getUserDataAndCsrfToken() {\n  return new Promise(function (resolve, reject) {\n    getWaitOnUserDataHandler({\n      resolve: resolve,\n      reject: reject\n    })();\n  });\n}\nexport function scrollToBottom() {\n  var element = document.getElementById('messagelist');\n  element.scrollTop = element.scrollHeight;\n}\nexport function setupObserver(callback) {\n  var sentinel = document.getElementById('messagelist__sentinel');\n  var somethingObserver = new IntersectionObserver(callback, {\n    threshold: [0, 1]\n  });\n  somethingObserver.observe(sentinel);\n}\nexport function hideMessages(messages, userId) {\n  var cleanedMessages = Object.keys(messages).reduce(function (accumulator, channelId) {\n    var newMessages = messages[channelId].map(function (message) {\n      if (message.user_id === userId) {\n        var messageClone = Object.assign({\n          type: 'hidden'\n        }, message);\n        messageClone.message = '<message removed>';\n        messageClone.messageColor = 'lightgray';\n        return messageClone;\n      }\n\n      return message;\n    });\n    return _objectSpread(_objectSpread({}, accumulator), {}, _defineProperty({}, channelId, newMessages));\n  }, {});\n  return cleanedMessages;\n}\nexport function adjustTimestamp(timestamp) {\n  var time = new Date(timestamp);\n  var options = {\n    month: 'long',\n    day: 'numeric',\n    hour: 'numeric',\n    minute: 'numeric'\n  };\n  time = new Intl.DateTimeFormat('en-US', options).format(time);\n  return time;\n}\nexport var channelSorter = function channelSorter(channels, currentUserId, filterQuery) {\n  var activeChannels = channels.filter(function (channel) {\n    return channel.viewable_by === currentUserId && channel.status === 'active';\n  });\n  var joiningChannels = channels.filter(function (channel) {\n    return channel.status === 'joining_request';\n  });\n  var ChannelIds = [_toConsumableArray(new Set(activeChannels.map(function (x) {\n    return x.chat_channel_id;\n  }))), _toConsumableArray(new Set(joiningChannels.map(function (x) {\n    return x.chat_channel_id;\n  })))];\n  var discoverableChannels = channels.filter(function (channel) {\n    return channel.status === 'joining_request' && filterQuery || !ChannelIds[1].includes(channel.chat_channel_id) && channel.viewable_by !== currentUserId;\n  }).filter(function (channel) {\n    return !ChannelIds[0].includes(channel.chat_channel_id);\n  });\n  return {\n    activeChannels: activeChannels,\n    discoverableChannels: discoverableChannels\n  };\n};\nexport var createDataHash = function createDataHash(additionalFilters, searchParams) {\n  var dataHash = {};\n\n  if (additionalFilters.filters) {\n    var _additionalFilters$fi = additionalFilters.filters.split(':'),\n        _additionalFilters$fi2 = _slicedToArray(_additionalFilters$fi, 2),\n        key = _additionalFilters$fi2[0],\n        value = _additionalFilters$fi2[1];\n\n    dataHash[key] = value;\n  }\n\n  dataHash.per_page = 30;\n  dataHash.page = searchParams.paginationNumber;\n  dataHash.channel_text = searchParams.query;\n\n  if (searchParams.searchType === 'discoverable') {\n    dataHash.user_id = 'all';\n  }\n\n  return fetchSearch('chat_channels', dataHash);\n};","map":{"version":3,"sources":["/Users/nmadhab/hobby/forem/app/javascript/chat/util.js"],"names":["fetchSearch","getCsrfToken","element","document","querySelector","content","undefined","getWaitOnUserDataHandler","resolve","reject","waitTime","totalTimeWaiting","waitingOnUserData","Error","csrfToken","user","body","dataset","currentUser","JSON","parse","setTimeout","getCurrentUser","getUserDataAndCsrfToken","Promise","scrollToBottom","getElementById","scrollTop","scrollHeight","setupObserver","callback","sentinel","somethingObserver","IntersectionObserver","threshold","observe","hideMessages","messages","userId","cleanedMessages","Object","keys","reduce","accumulator","channelId","newMessages","map","message","user_id","messageClone","assign","type","messageColor","adjustTimestamp","timestamp","time","Date","options","month","day","hour","minute","Intl","DateTimeFormat","format","channelSorter","channels","currentUserId","filterQuery","activeChannels","filter","channel","viewable_by","status","joiningChannels","ChannelIds","Set","x","chat_channel_id","discoverableChannels","includes","createDataHash","additionalFilters","searchParams","dataHash","filters","split","key","value","per_page","page","paginationNumber","channel_text","query","searchType"],"mappings":"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","sourcesContent":["import { fetchSearch } from '../utilities/search';\n\nimport 'intersection-observer';\n\nexport function getCsrfToken() {\n  const element = document.querySelector(`meta[name='csrf-token']`);\n\n  return element !== null ? element.content : undefined;\n}\n\nconst getWaitOnUserDataHandler = ({ resolve, reject, waitTime = 20 }) => {\n  let totalTimeWaiting = 0;\n\n  return function waitingOnUserData() {\n    if (totalTimeWaiting === 3000) {\n      reject(new Error(\"Couldn't find user data on page.\"));\n      return;\n    }\n\n    const csrfToken = getCsrfToken(document);\n    const { user } = document.body.dataset;\n\n    if (user && csrfToken !== undefined) {\n      const currentUser = JSON.parse(user);\n\n      resolve({ currentUser, csrfToken });\n      return;\n    }\n\n    totalTimeWaiting += waitTime;\n    setTimeout(waitingOnUserData, waitTime);\n  };\n};\n\nexport const getCurrentUser = () => {\n  const { user } = document.body.dataset;\n  return JSON.parse(user);\n};\n\nexport function getUserDataAndCsrfToken() {\n  return new Promise((resolve, reject) => {\n    getWaitOnUserDataHandler({ resolve, reject })();\n  });\n}\n\nexport function scrollToBottom() {\n  const element = document.getElementById('messagelist');\n  element.scrollTop = element.scrollHeight;\n}\n\nexport function setupObserver(callback) {\n  const sentinel = document.getElementById('messagelist__sentinel');\n  const somethingObserver = new IntersectionObserver(callback, {\n    threshold: [0, 1],\n  });\n  somethingObserver.observe(sentinel);\n}\n\nexport function hideMessages(messages, userId) {\n  const cleanedMessages = Object.keys(messages).reduce(\n    (accumulator, channelId) => {\n      const newMessages = messages[channelId].map((message) => {\n        if (message.user_id === userId) {\n          const messageClone = Object.assign({ type: 'hidden' }, message);\n          messageClone.message = '<message removed>';\n          messageClone.messageColor = 'lightgray';\n          return messageClone;\n        }\n        return message;\n      });\n      return { ...accumulator, [channelId]: newMessages };\n    },\n    {},\n  );\n  return cleanedMessages;\n}\n\nexport function adjustTimestamp(timestamp) {\n  let time = new Date(timestamp);\n  const options = {\n    month: 'long',\n    day: 'numeric',\n    hour: 'numeric',\n    minute: 'numeric',\n  };\n  time = new Intl.DateTimeFormat('en-US', options).format(time);\n  return time;\n}\n\nexport const channelSorter = (channels, currentUserId, filterQuery) => {\n  const activeChannels = channels.filter(\n    (channel) =>\n      channel.viewable_by === currentUserId && channel.status === 'active',\n  );\n  const joiningChannels = channels.filter(\n    (channel) => channel.status === 'joining_request',\n  );\n  const ChannelIds = [\n    [...new Set(activeChannels.map((x) => x.chat_channel_id))],\n    [...new Set(joiningChannels.map((x) => x.chat_channel_id))],\n  ];\n  const discoverableChannels = channels\n    .filter(\n      (channel) =>\n        (channel.status === 'joining_request' && filterQuery) ||\n        (!ChannelIds[1].includes(channel.chat_channel_id) &&\n          channel.viewable_by !== currentUserId),\n    )\n    .filter((channel) => !ChannelIds[0].includes(channel.chat_channel_id));\n  return { activeChannels, discoverableChannels };\n};\n\nexport const createDataHash = (additionalFilters, searchParams) => {\n  const dataHash = {};\n  if (additionalFilters.filters) {\n    const [key, value] = additionalFilters.filters.split(':');\n    dataHash[key] = value;\n  }\n  dataHash.per_page = 30;\n  dataHash.page = searchParams.paginationNumber;\n  dataHash.channel_text = searchParams.query;\n  if (searchParams.searchType === 'discoverable') {\n    dataHash.user_id = 'all';\n  }\n  return fetchSearch('chat_channels', dataHash);\n};\n"]},"metadata":{},"sourceType":"module"}