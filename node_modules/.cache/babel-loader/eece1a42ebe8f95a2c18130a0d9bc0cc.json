{"ast":null,"code":"function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { validateFileInputs } from '../packs/validateFileInputs';\nexport function previewArticle(payload, successCb, failureCb) {\n  fetch('/articles/preview', {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'X-CSRF-Token': window.csrfToken,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      article_body: payload\n    }),\n    credentials: 'same-origin'\n  }).then(function (response) {\n    return response.json();\n  }).then(successCb)[\"catch\"](failureCb);\n}\nexport function getArticle() {}\n\nfunction processPayload(payload) {\n  var previewShowing = payload.previewShowing,\n      helpShowing = payload.helpShowing,\n      previewResponse = payload.previewResponse,\n      helpHTML = payload.helpHTML,\n      imageManagementShowing = payload.imageManagementShowing,\n      moreConfigShowing = payload.moreConfigShowing,\n      errors = payload.errors,\n      neededPayload = _objectWithoutProperties(payload, [\"previewShowing\", \"helpShowing\", \"previewResponse\", \"helpHTML\", \"imageManagementShowing\", \"moreConfigShowing\", \"errors\"]);\n\n  return neededPayload;\n}\n\nexport function submitArticle(payload, clearStorage, errorCb, failureCb) {\n  var method = payload.id ? 'PUT' : 'POST';\n  var url = payload.id ? \"/articles/\".concat(payload.id) : '/articles';\n  fetch(url, {\n    method: method,\n    headers: {\n      Accept: 'application/json',\n      'X-CSRF-Token': window.csrfToken,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      article: processPayload(payload)\n    }),\n    credentials: 'same-origin'\n  }).then(function (response) {\n    return response.json();\n  }).then(function (response) {\n    if (response.current_state_path) {\n      clearStorage();\n      window.location.replace(response.current_state_path);\n    } else {\n      // If there is an error and the method is POST, we know they are trying to publish.\n      errorCb(response, method === 'POST');\n    }\n  })[\"catch\"](failureCb);\n}\n\nfunction generateUploadFormdata(payload) {\n  var token = window.csrfToken;\n  var formData = new FormData();\n  formData.append('authenticity_token', token);\n  Object.entries(payload.image).forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        _ = _ref2[0],\n        value = _ref2[1];\n\n    return formData.append('image[]', value);\n  });\n  return formData;\n}\n\nexport function generateMainImage(payload, successCb, failureCb) {\n  fetch('/image_uploads', {\n    method: 'POST',\n    headers: {\n      'X-CSRF-Token': window.csrfToken\n    },\n    body: generateUploadFormdata(payload),\n    credentials: 'same-origin'\n  }).then(function (response) {\n    return response.json();\n  }).then(function (json) {\n    if (json.error) {\n      throw new Error(json.error);\n    }\n\n    var links = json.links;\n    var image = payload.image;\n    return successCb({\n      links: links,\n      image: image\n    });\n  })[\"catch\"](failureCb);\n}\n/**\n * Processes images for upload.\n *\n * @param {FileList} images Images to be uploaded.\n * @param {Function} handleImageSuccess The handler that runs when the image is uploaded successfully.\n * @param {Function} handleImageFailure The handler that runs when the image upload fails.\n */\n\nexport function processImageUpload(images, handleImageSuccess, handleImageFailure) {\n  // Currently only one image is supported for upload.\n  if (images.length > 0 && validateFileInputs()) {\n    var payload = {\n      image: images\n    };\n    generateMainImage(payload, handleImageSuccess, handleImageFailure);\n  }\n}","map":{"version":3,"sources":["/Users/nmadhab/hobby/forem/app/javascript/article-form/actions.js"],"names":["validateFileInputs","previewArticle","payload","successCb","failureCb","fetch","method","headers","Accept","window","csrfToken","body","JSON","stringify","article_body","credentials","then","response","json","getArticle","processPayload","previewShowing","helpShowing","previewResponse","helpHTML","imageManagementShowing","moreConfigShowing","errors","neededPayload","submitArticle","clearStorage","errorCb","id","url","article","current_state_path","location","replace","generateUploadFormdata","token","formData","FormData","append","Object","entries","image","forEach","_","value","generateMainImage","error","Error","links","processImageUpload","images","handleImageSuccess","handleImageFailure","length"],"mappings":"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","sourcesContent":["import { validateFileInputs } from '../packs/validateFileInputs';\n\nexport function previewArticle(payload, successCb, failureCb) {\n  fetch('/articles/preview', {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'X-CSRF-Token': window.csrfToken,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      article_body: payload,\n    }),\n    credentials: 'same-origin',\n  })\n    .then((response) => response.json())\n    .then(successCb)\n    .catch(failureCb);\n}\n\nexport function getArticle() {}\n\nfunction processPayload(payload) {\n  const {\n    /* eslint-disable no-unused-vars */\n    previewShowing,\n    helpShowing,\n    previewResponse,\n    helpHTML,\n    imageManagementShowing,\n    moreConfigShowing,\n    errors,\n    /* eslint-enable no-unused-vars */\n    ...neededPayload\n  } = payload;\n  return neededPayload;\n}\n\nexport function submitArticle(payload, clearStorage, errorCb, failureCb) {\n  const method = payload.id ? 'PUT' : 'POST';\n  const url = payload.id ? `/articles/${payload.id}` : '/articles';\n  fetch(url, {\n    method,\n    headers: {\n      Accept: 'application/json',\n      'X-CSRF-Token': window.csrfToken,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      article: processPayload(payload),\n    }),\n    credentials: 'same-origin',\n  })\n    .then((response) => response.json())\n    .then((response) => {\n      if (response.current_state_path) {\n        clearStorage();\n        window.location.replace(response.current_state_path);\n      } else {\n        // If there is an error and the method is POST, we know they are trying to publish.\n        errorCb(response, method === 'POST');\n      }\n    })\n    .catch(failureCb);\n}\n\nfunction generateUploadFormdata(payload) {\n  const token = window.csrfToken;\n  const formData = new FormData();\n  formData.append('authenticity_token', token);\n\n  Object.entries(payload.image).forEach(([_, value]) =>\n    formData.append('image[]', value),\n  );\n\n  return formData;\n}\n\nexport function generateMainImage(payload, successCb, failureCb) {\n  fetch('/image_uploads', {\n    method: 'POST',\n    headers: {\n      'X-CSRF-Token': window.csrfToken,\n    },\n    body: generateUploadFormdata(payload),\n    credentials: 'same-origin',\n  })\n    .then((response) => response.json())\n    .then((json) => {\n      if (json.error) {\n        throw new Error(json.error);\n      }\n      const { links } = json;\n      const { image } = payload;\n      return successCb({ links, image });\n    })\n    .catch(failureCb);\n}\n\n/**\n * Processes images for upload.\n *\n * @param {FileList} images Images to be uploaded.\n * @param {Function} handleImageSuccess The handler that runs when the image is uploaded successfully.\n * @param {Function} handleImageFailure The handler that runs when the image upload fails.\n */\nexport function processImageUpload(\n  images,\n  handleImageSuccess,\n  handleImageFailure,\n) {\n  // Currently only one image is supported for upload.\n  if (images.length > 0 && validateFileInputs()) {\n    const payload = { image: images };\n\n    generateMainImage(payload, handleImageSuccess, handleImageFailure);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}