{"ast":null,"code":"function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n// Shared behavior between the reading list and history pages\nimport { fetchSearch } from '../utilities/search'; // Provides the initial state for the component\n\nexport function defaultState(options) {\n  var state = {\n    query: '',\n    index: null,\n    page: 0,\n    hitsPerPage: 80,\n    totalCount: 0,\n    items: [],\n    itemsLoaded: false,\n    availableTags: [],\n    selectedTags: [],\n    showLoadMoreButton: false\n  };\n  return Object.assign({}, state, options);\n} // Starts the search when the user types in the search box\n\nexport function onSearchBoxType(event) {\n  var component = this;\n  var query = event.target.value;\n  var _component$state = component.state,\n      selectedTags = _component$state.selectedTags,\n      statusView = _component$state.statusView;\n  component.setState({\n    page: 0\n  });\n  component.search(query, {\n    tags: selectedTags,\n    statusView: statusView,\n    appendItems: false\n  });\n}\nexport function toggleTag(event, tag) {\n  event.preventDefault();\n  var component = this;\n  var _component$state2 = component.state,\n      query = _component$state2.query,\n      selectedTags = _component$state2.selectedTags,\n      statusView = _component$state2.statusView;\n  var newTags = selectedTags;\n\n  if (newTags.indexOf(tag) === -1) {\n    newTags.push(tag);\n  } else {\n    newTags.splice(newTags.indexOf(tag), 1);\n  }\n\n  component.setState({\n    selectedTags: newTags,\n    page: 0,\n    items: []\n  });\n  component.search(query, {\n    tags: newTags,\n    statusView: statusView,\n    appendItems: false\n  });\n}\nexport function clearSelectedTags(event) {\n  event.preventDefault();\n  var component = this;\n  var _component$state3 = component.state,\n      query = _component$state3.query,\n      statusView = _component$state3.statusView;\n  var newTags = [];\n  component.setState({\n    selectedTags: newTags,\n    page: 0,\n    items: []\n  });\n  component.search(query, {\n    tags: newTags,\n    statusView: statusView,\n    appendItems: false\n  });\n} // Perform the initial search\n\nexport function performInitialSearch(_ref) {\n  var _ref$searchOptions = _ref.searchOptions,\n      searchOptions = _ref$searchOptions === void 0 ? {} : _ref$searchOptions;\n  var component = this;\n  var hitsPerPage = component.state.hitsPerPage;\n  var dataHash = {\n    page: 0,\n    per_page: hitsPerPage\n  };\n\n  if (searchOptions.status) {\n    dataHash.status = searchOptions.status.split(',');\n  }\n\n  var responsePromise = fetchSearch('reactions', dataHash);\n  return responsePromise.then(function (response) {\n    var reactions = response.result;\n\n    var availableTags = _toConsumableArray(new Set(reactions.flatMap(function (rxn) {\n      return rxn.reactable.tag_list;\n    }))).sort();\n\n    component.setState({\n      page: 0,\n      items: reactions,\n      itemsLoaded: true,\n      totalCount: response.total,\n      showLoadMoreButton: hitsPerPage < response.total,\n      availableTags: availableTags\n    });\n  });\n} // Main search function\n\nexport function search(query, _ref2) {\n  var page = _ref2.page,\n      tags = _ref2.tags,\n      statusView = _ref2.statusView,\n      _ref2$appendItems = _ref2.appendItems,\n      appendItems = _ref2$appendItems === void 0 ? false : _ref2$appendItems;\n  var component = this; // allow the page number to come from the calling function\n  // we check `undefined` because page can be 0\n\n  var newPage = page === undefined ? component.state.page : page;\n  var _component$state4 = component.state,\n      hitsPerPage = _component$state4.hitsPerPage,\n      existingItems = _component$state4.items;\n  var dataHash = {\n    search_fields: query,\n    page: newPage,\n    per_page: hitsPerPage\n  };\n\n  if (tags && tags.length > 0) {\n    dataHash.tag_names = tags;\n    dataHash.tag_boolean_mode = 'all';\n  }\n\n  if (statusView) {\n    dataHash.status = statusView.split(',');\n  }\n\n  var responsePromise = fetchSearch('reactions', dataHash);\n  return responsePromise.then(function (response) {\n    var reactions = response.result;\n    var items;\n\n    if (appendItems) {\n      // we append the new reactions at the bottom of the list, for pagination\n      items = [].concat(_toConsumableArray(existingItems), _toConsumableArray(reactions));\n    } else {\n      items = reactions;\n    }\n\n    component.setState({\n      query: query,\n      page: newPage,\n      items: items,\n      totalCount: response.total,\n      showLoadMoreButton: items.length < response.total\n    });\n  });\n} // Retrieve the results in the next page\n\nexport function loadNextPage() {\n  var component = this;\n  var _component$state5 = component.state,\n      query = _component$state5.query,\n      selectedTags = _component$state5.selectedTags,\n      page = _component$state5.page,\n      statusView = _component$state5.statusView;\n  component.setState({\n    page: page + 1\n  });\n  component.search(query, {\n    page: page + 1,\n    tags: selectedTags,\n    statusView: statusView,\n    appendItems: true\n  });\n}","map":{"version":3,"sources":["/Users/nmadhab/hobby/forem/app/javascript/searchableItemList/searchableItemList.js"],"names":["fetchSearch","defaultState","options","state","query","index","page","hitsPerPage","totalCount","items","itemsLoaded","availableTags","selectedTags","showLoadMoreButton","Object","assign","onSearchBoxType","event","component","target","value","statusView","setState","search","tags","appendItems","toggleTag","tag","preventDefault","newTags","indexOf","push","splice","clearSelectedTags","performInitialSearch","searchOptions","dataHash","per_page","status","split","responsePromise","then","response","reactions","result","Set","flatMap","rxn","reactable","tag_list","sort","total","newPage","undefined","existingItems","search_fields","length","tag_names","tag_boolean_mode","loadNextPage"],"mappings":"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","sourcesContent":["// Shared behavior between the reading list and history pages\nimport { fetchSearch } from '../utilities/search';\n\n// Provides the initial state for the component\nexport function defaultState(options) {\n  const state = {\n    query: '',\n    index: null,\n\n    page: 0,\n    hitsPerPage: 80,\n    totalCount: 0,\n\n    items: [],\n    itemsLoaded: false,\n\n    availableTags: [],\n    selectedTags: [],\n\n    showLoadMoreButton: false,\n  };\n  return Object.assign({}, state, options);\n}\n\n// Starts the search when the user types in the search box\nexport function onSearchBoxType(event) {\n  const component = this;\n\n  const query = event.target.value;\n  const { selectedTags, statusView } = component.state;\n\n  component.setState({ page: 0 });\n  component.search(query, {\n    tags: selectedTags,\n    statusView,\n    appendItems: false,\n  });\n}\n\nexport function toggleTag(event, tag) {\n  event.preventDefault();\n\n  const component = this;\n  const { query, selectedTags, statusView } = component.state;\n  const newTags = selectedTags;\n  if (newTags.indexOf(tag) === -1) {\n    newTags.push(tag);\n  } else {\n    newTags.splice(newTags.indexOf(tag), 1);\n  }\n  component.setState({ selectedTags: newTags, page: 0, items: [] });\n  component.search(query, { tags: newTags, statusView, appendItems: false });\n}\n\nexport function clearSelectedTags(event) {\n  event.preventDefault();\n\n  const component = this;\n  const { query, statusView } = component.state;\n  const newTags = [];\n  component.setState({ selectedTags: newTags, page: 0, items: [] });\n  component.search(query, { tags: newTags, statusView, appendItems: false });\n}\n\n// Perform the initial search\nexport function performInitialSearch({ searchOptions = {} }) {\n  const component = this;\n  const { hitsPerPage } = component.state;\n  const dataHash = { page: 0, per_page: hitsPerPage };\n\n  if (searchOptions.status) {\n    dataHash.status = searchOptions.status.split(',');\n  }\n\n  const responsePromise = fetchSearch('reactions', dataHash);\n  return responsePromise.then((response) => {\n    const reactions = response.result;\n    const availableTags = [\n      ...new Set(reactions.flatMap((rxn) => rxn.reactable.tag_list)),\n    ].sort();\n    component.setState({\n      page: 0,\n      items: reactions,\n      itemsLoaded: true,\n      totalCount: response.total,\n      showLoadMoreButton: hitsPerPage < response.total,\n      availableTags,\n    });\n  });\n}\n\n// Main search function\nexport function search(query, { page, tags, statusView, appendItems = false }) {\n  const component = this;\n\n  // allow the page number to come from the calling function\n  // we check `undefined` because page can be 0\n  const newPage = page === undefined ? component.state.page : page;\n\n  const { hitsPerPage, items: existingItems } = component.state;\n\n  const dataHash = {\n    search_fields: query,\n    page: newPage,\n    per_page: hitsPerPage,\n  };\n\n  if (tags && tags.length > 0) {\n    dataHash.tag_names = tags;\n    dataHash.tag_boolean_mode = 'all';\n  }\n\n  if (statusView) {\n    dataHash.status = statusView.split(',');\n  }\n\n  const responsePromise = fetchSearch('reactions', dataHash);\n  return responsePromise.then((response) => {\n    const reactions = response.result;\n\n    let items;\n    if (appendItems) {\n      // we append the new reactions at the bottom of the list, for pagination\n      items = [...existingItems, ...reactions];\n    } else {\n      items = reactions;\n    }\n\n    component.setState({\n      query,\n      page: newPage,\n      items,\n      totalCount: response.total,\n      showLoadMoreButton: items.length < response.total,\n    });\n  });\n}\n\n// Retrieve the results in the next page\nexport function loadNextPage() {\n  const component = this;\n\n  const { query, selectedTags, page, statusView } = component.state;\n  component.setState({ page: page + 1 });\n  component.search(query, {\n    page: page + 1,\n    tags: selectedTags,\n    statusView,\n    appendItems: true,\n  });\n}\n"]},"metadata":{},"sourceType":"module"}