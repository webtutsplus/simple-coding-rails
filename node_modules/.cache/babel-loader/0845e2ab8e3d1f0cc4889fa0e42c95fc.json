{"ast":null,"code":"function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport { useState, useEffect, useCallback } from 'preact/hooks';\nimport PropTypes from 'prop-types';\n/**\n * Checker that return true if element is a form element\n *\n * @param {node} element to be checked\n *\n * @returns {boolean} isFormField\n */\n\nfunction isFormField(element) {\n  if (element instanceof HTMLElement === false) return false;\n  var name = element.nodeName.toLowerCase();\n  var type = (element.getAttribute('type') || '').toLowerCase();\n  return name === 'select' || name === 'textarea' || name === 'input' && type !== 'submit' && type !== 'reset' && type !== 'checkbox' && type !== 'radio' || element.isContentEditable;\n} // Default options to be used if null\n\n\nvar defaultOptions = {\n  timeout: 0 // The default is zero as we want no delays between keystrokes by default.\n\n};\n/**\n * hook that can be added to a component to listen\n * for keyboard presses\n *\n * @example\n * const shortcuts = {\n *   \"ctrl+alt+KeyG\": (e) => {\n *     e.preventDefault();\n *     alert(\"Control Alt G has been pressed\");\n *   },\n *   \"KeyG~KeyH\": (e) => {\n *     e.preventDefault();\n *     alert(\"G has been pressed quickly followed by H\");\n *   },\n *   \"?\": (e) => {\n *     setIsHelpVisible(true);\n *   }\n * }\n *\n * useKeyboardShortcuts(shortcuts, someElementOrWindowObject, {timeout: 1500});\n *\n * @param {object} shortcuts List of keyboard shortcuts/event\n * @param {EventTarget} [eventTarget=window] An event target.\n * @param {object} [options = {}] An object for extra options\n *\n */\n\nexport function useKeyboardShortcuts(shortcuts) {\n  var eventTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _useState = useState([]),\n      _useState2 = _slicedToArray(_useState, 2),\n      keyChain = _useState2[0],\n      setKeyChain = _useState2[1];\n\n  var _useState3 = useState(null),\n      _useState4 = _slicedToArray(_useState3, 2),\n      keyChainQueue = _useState4[0],\n      setKeyChainQueue = _useState4[1];\n\n  var _useState5 = useState(_objectSpread(_objectSpread({}, defaultOptions), options)),\n      _useState6 = _slicedToArray(_useState5, 2),\n      mergedOptions = _useState6[0],\n      setMergedOptions = _useState6[1]; // Work out the correct shortcut for the key press\n\n\n  var callShortcut = useCallback(function (e, keys) {\n    var shortcut;\n\n    if (keyChain.length > 0) {\n      shortcut = shortcuts[\"\".concat(keyChain.join('~'), \"~\").concat(e.code)];\n    } else {\n      shortcut = shortcuts[\"\".concat(keys).concat(e.code)] || shortcuts[\"\".concat(keys).concat(e.key.toLowerCase())];\n    } // if a valid shortcut is found call it and reset the chain\n\n\n    if (shortcut) {\n      shortcut(e);\n      setKeyChain([]);\n    }\n  }, [shortcuts, keyChain]); // update mergedOptions if options prop changes\n\n  useEffect(function () {\n    var newOptions = {};\n    if (typeof options.timeout === 'number') newOptions.timeout = options.timeout;\n    setMergedOptions(_objectSpread(_objectSpread({}, defaultOptions), newOptions));\n  }, [options.timeout]); // Set up key chains\n\n  useEffect(function () {\n    if (!keyChainQueue && keyChain.length === 0) return;\n    var timeout;\n    timeout = window.setTimeout(function () {\n      clearTimeout(timeout);\n      setKeyChain([]);\n    }, mergedOptions.timeout);\n\n    if (keyChainQueue) {\n      setKeyChain([].concat(_toConsumableArray(keyChain), [keyChainQueue]));\n      setKeyChainQueue(null);\n    }\n\n    return function () {\n      return clearTimeout(timeout);\n    };\n  }, [keyChain, keyChainQueue, mergedOptions.timeout]); // set up event listeners\n\n  useEffect(function () {\n    if (!shortcuts || Object.keys(shortcuts).length === 0) return;\n\n    var keyEvent = function keyEvent(e) {\n      if (e.defaultPrevented) return; // Get special keys\n\n      var keys = \"\".concat(e.ctrlKey || e.metaKey ? 'ctrl+' : '').concat(e.altKey ? 'alt+' : '').concat((e.ctrlKey || e.metaKey || e.altKey) && e.shiftKey ? 'shift+' : ''); // If no special keys, except shift, are pressed and focus is inside a field return\n\n      if (e.target instanceof Node && isFormField(e.target) && !keys) return; // If a special key is pressed reset the key chain else add to the chain\n\n      if (keys) {\n        setKeyChain([]);\n      } else {\n        setKeyChainQueue(e.code);\n      }\n\n      callShortcut(e, keys);\n    };\n\n    eventTarget.addEventListener('keydown', keyEvent);\n    return function () {\n      return eventTarget.removeEventListener('keydown', keyEvent);\n    };\n  }, [shortcuts, eventTarget, callShortcut]);\n}\n/**\n * A component that can be added to a component to listen\n * for keyboard presses using the useKeyboardShortcuts hook\n *\n * @example\n * const shortcuts = {\n *   \"ctrl+alt+KeyG\": (e) => {\n *     e.preventDefault();\n *     alert(\"Control Alt G has been pressed\")\n *   }\n * }\n *\n * <KeyboardShortcuts shortcuts={shortcuts} />\n * <KeyboardShortcuts shortcuts={shortcuts} eventTarget={ref.current} />\n *\n * @param {object} shortcuts List of keyboard shortcuts/event\n * @param {EventTarget} [eventTarget=window] An event target.\n * @param {object} [options = {}] An object for extra options\n *\n */\n\nexport function KeyboardShortcuts(_ref) {\n  var shortcuts = _ref.shortcuts,\n      eventTarget = _ref.eventTarget,\n      options = _ref.options;\n  useKeyboardShortcuts(shortcuts, eventTarget, options);\n  return null;\n}\nKeyboardShortcuts.propTypes = {\n  shortcuts: PropTypes.object.isRequired,\n  options: PropTypes.shape({\n    timeout: PropTypes.number\n  }),\n  eventTarget: PropTypes.instanceOf(Element)\n};\nKeyboardShortcuts.defaultProps = {\n  shortcuts: {},\n  options: {},\n  eventTarget: window\n};","map":{"version":3,"sources":["/Users/nmadhab/hobby/forem/app/javascript/shared/components/useKeyboardShortcuts.js"],"names":["useState","useEffect","useCallback","PropTypes","isFormField","element","HTMLElement","name","nodeName","toLowerCase","type","getAttribute","isContentEditable","defaultOptions","timeout","useKeyboardShortcuts","shortcuts","eventTarget","window","options","keyChain","setKeyChain","keyChainQueue","setKeyChainQueue","mergedOptions","setMergedOptions","callShortcut","e","keys","shortcut","length","join","code","key","newOptions","setTimeout","clearTimeout","Object","keyEvent","defaultPrevented","ctrlKey","metaKey","altKey","shiftKey","target","Node","addEventListener","removeEventListener","KeyboardShortcuts","propTypes","object","isRequired","shape","number","instanceOf","Element","defaultProps"],"mappings":"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","sourcesContent":["import { useState, useEffect, useCallback } from 'preact/hooks';\nimport PropTypes from 'prop-types';\n\n/**\n * Checker that return true if element is a form element\n *\n * @param {node} element to be checked\n *\n * @returns {boolean} isFormField\n */\nfunction isFormField(element) {\n  if (element instanceof HTMLElement === false) return false;\n\n  const name = element.nodeName.toLowerCase();\n  const type = (element.getAttribute('type') || '').toLowerCase();\n  return (\n    name === 'select' ||\n    name === 'textarea' ||\n    (name === 'input' &&\n      type !== 'submit' &&\n      type !== 'reset' &&\n      type !== 'checkbox' &&\n      type !== 'radio') ||\n    element.isContentEditable\n  );\n}\n\n// Default options to be used if null\nconst defaultOptions = {\n  timeout: 0, // The default is zero as we want no delays between keystrokes by default.\n};\n\n/**\n * hook that can be added to a component to listen\n * for keyboard presses\n *\n * @example\n * const shortcuts = {\n *   \"ctrl+alt+KeyG\": (e) => {\n *     e.preventDefault();\n *     alert(\"Control Alt G has been pressed\");\n *   },\n *   \"KeyG~KeyH\": (e) => {\n *     e.preventDefault();\n *     alert(\"G has been pressed quickly followed by H\");\n *   },\n *   \"?\": (e) => {\n *     setIsHelpVisible(true);\n *   }\n * }\n *\n * useKeyboardShortcuts(shortcuts, someElementOrWindowObject, {timeout: 1500});\n *\n * @param {object} shortcuts List of keyboard shortcuts/event\n * @param {EventTarget} [eventTarget=window] An event target.\n * @param {object} [options = {}] An object for extra options\n *\n */\nexport function useKeyboardShortcuts(\n  shortcuts,\n  eventTarget = window,\n  options = {},\n) {\n  const [keyChain, setKeyChain] = useState([]);\n  const [keyChainQueue, setKeyChainQueue] = useState(null);\n  const [mergedOptions, setMergedOptions] = useState({\n    ...defaultOptions,\n    ...options,\n  });\n\n  // Work out the correct shortcut for the key press\n  const callShortcut = useCallback(\n    (e, keys) => {\n      let shortcut;\n      if (keyChain.length > 0) {\n        shortcut = shortcuts[`${keyChain.join('~')}~${e.code}`];\n      } else {\n        shortcut =\n          shortcuts[`${keys}${e.code}`] ||\n          shortcuts[`${keys}${e.key.toLowerCase()}`];\n      }\n\n      // if a valid shortcut is found call it and reset the chain\n      if (shortcut) {\n        shortcut(e);\n        setKeyChain([]);\n      }\n    },\n    [shortcuts, keyChain],\n  );\n\n  // update mergedOptions if options prop changes\n  useEffect(() => {\n    const newOptions = {};\n    if (typeof options.timeout === 'number')\n      newOptions.timeout = options.timeout;\n    setMergedOptions({ ...defaultOptions, ...newOptions });\n  }, [options.timeout]);\n\n  // Set up key chains\n  useEffect(() => {\n    if (!keyChainQueue && keyChain.length === 0) return;\n    let timeout;\n\n    timeout = window.setTimeout(() => {\n      clearTimeout(timeout);\n      setKeyChain([]);\n    }, mergedOptions.timeout);\n\n    if (keyChainQueue) {\n      setKeyChain([...keyChain, keyChainQueue]);\n      setKeyChainQueue(null);\n    }\n\n    return () => clearTimeout(timeout);\n  }, [keyChain, keyChainQueue, mergedOptions.timeout]);\n\n  // set up event listeners\n  useEffect(() => {\n    if (!shortcuts || Object.keys(shortcuts).length === 0) return;\n\n    const keyEvent = (e) => {\n      if (e.defaultPrevented) return;\n\n      // Get special keys\n      const keys = `${e.ctrlKey || e.metaKey ? 'ctrl+' : ''}${\n        e.altKey ? 'alt+' : ''\n      }${(e.ctrlKey || e.metaKey || e.altKey) && e.shiftKey ? 'shift+' : ''}`;\n\n      // If no special keys, except shift, are pressed and focus is inside a field return\n      if (e.target instanceof Node && isFormField(e.target) && !keys) return;\n\n      // If a special key is pressed reset the key chain else add to the chain\n      if (keys) {\n        setKeyChain([]);\n      } else {\n        setKeyChainQueue(e.code);\n      }\n\n      callShortcut(e, keys);\n    };\n\n    eventTarget.addEventListener('keydown', keyEvent);\n\n    return () => eventTarget.removeEventListener('keydown', keyEvent);\n  }, [shortcuts, eventTarget, callShortcut]);\n}\n\n/**\n * A component that can be added to a component to listen\n * for keyboard presses using the useKeyboardShortcuts hook\n *\n * @example\n * const shortcuts = {\n *   \"ctrl+alt+KeyG\": (e) => {\n *     e.preventDefault();\n *     alert(\"Control Alt G has been pressed\")\n *   }\n * }\n *\n * <KeyboardShortcuts shortcuts={shortcuts} />\n * <KeyboardShortcuts shortcuts={shortcuts} eventTarget={ref.current} />\n *\n * @param {object} shortcuts List of keyboard shortcuts/event\n * @param {EventTarget} [eventTarget=window] An event target.\n * @param {object} [options = {}] An object for extra options\n *\n */\nexport function KeyboardShortcuts({ shortcuts, eventTarget, options }) {\n  useKeyboardShortcuts(shortcuts, eventTarget, options);\n\n  return null;\n}\n\nKeyboardShortcuts.propTypes = {\n  shortcuts: PropTypes.object.isRequired,\n  options: PropTypes.shape({\n    timeout: PropTypes.number,\n  }),\n  eventTarget: PropTypes.instanceOf(Element),\n};\n\nKeyboardShortcuts.defaultProps = {\n  shortcuts: {},\n  options: {},\n  eventTarget: window,\n};\n"]},"metadata":{},"sourceType":"module"}