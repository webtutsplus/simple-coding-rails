(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~articleForm"],{

/***/ "./node_modules/linkstate/dist/linkstate.module.js":
/*!*********************************************************!*\
  !*** ./node_modules/linkstate/dist/linkstate.module.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar t,r=(function(t,r){t.exports=function(t,r,e,n,o){for(r=r.split?r.split(\".\"):r,n=0;n<r.length;n++)t=t?t[r[n]]:o;return t===o?e:t}}(t={path:void 0,exports:{},require:function(t,r){return function(){throw new Error(\"Dynamic requires are not currently supported by @rollup/plugin-commonjs\")}()}}),t.exports);/* harmony default export */ __webpack_exports__[\"default\"] = (function(t,e,n){var o=e.split(\".\"),u=t.__lsc||(t.__lsc={});return u[e+n]||(u[e+n]=function(e){for(var u=e&&e.target||this,i={},c=i,s=\"string\"==typeof n?r(e,n):u&&u.nodeName?u.type.match(/^che|rad/)?u.checked:u.value:e,a=0;a<o.length-1;a++)c=c[o[a]]||(c[o[a]]=!a&&t.state[o[a]]||{});c[o[a]]=s,t.setState(i)})});\n//# sourceMappingURL=linkstate.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGlua3N0YXRlL2Rpc3QvbGlua3N0YXRlLm1vZHVsZS5qcz9iMjlmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUEsdUJBQXVCLDhCQUE4QixpQ0FBaUMsV0FBVyxrQkFBa0Isa0JBQWtCLElBQUksc0JBQXNCLHVCQUF1QixrQkFBa0IsMkZBQTJGLElBQUksYUFBNEIsK0VBQWdCLHlDQUF5QyxFQUFFLG1DQUFtQyxnQ0FBZ0MsZ0dBQWdHLGFBQWEsNkNBQTZDLEVBQUUsd0JBQXdCLEVBQUU7QUFDdm5CIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpbmtzdGF0ZS9kaXN0L2xpbmtzdGF0ZS5tb2R1bGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdCxyPShmdW5jdGlvbih0LHIpe3QuZXhwb3J0cz1mdW5jdGlvbih0LHIsZSxuLG8pe2ZvcihyPXIuc3BsaXQ/ci5zcGxpdChcIi5cIik6cixuPTA7bjxyLmxlbmd0aDtuKyspdD10P3RbcltuXV06bztyZXR1cm4gdD09PW8/ZTp0fX0odD17cGF0aDp2b2lkIDAsZXhwb3J0czp7fSxyZXF1aXJlOmZ1bmN0aW9uKHQscil7cmV0dXJuIGZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiRHluYW1pYyByZXF1aXJlcyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgQHJvbGx1cC9wbHVnaW4tY29tbW9uanNcIil9KCl9fSksdC5leHBvcnRzKTtleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0LGUsbil7dmFyIG89ZS5zcGxpdChcIi5cIiksdT10Ll9fbHNjfHwodC5fX2xzYz17fSk7cmV0dXJuIHVbZStuXXx8KHVbZStuXT1mdW5jdGlvbihlKXtmb3IodmFyIHU9ZSYmZS50YXJnZXR8fHRoaXMsaT17fSxjPWkscz1cInN0cmluZ1wiPT10eXBlb2Ygbj9yKGUsbik6dSYmdS5ub2RlTmFtZT91LnR5cGUubWF0Y2goL15jaGV8cmFkLyk/dS5jaGVja2VkOnUudmFsdWU6ZSxhPTA7YTxvLmxlbmd0aC0xO2ErKyljPWNbb1thXV18fChjW29bYV1dPSFhJiZ0LnN0YXRlW29bYV1dfHx7fSk7Y1tvW2FdXT1zLHQuc2V0U3RhdGUoaSl9KX1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmtzdGF0ZS5tb2R1bGUuanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/linkstate/dist/linkstate.module.js\n");

/***/ }),

/***/ "./node_modules/postscribe/dist/postscribe.js":
/*!****************************************************!*\
  !*** ./node_modules/postscribe/dist/postscribe.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @file postscribe\n * @description Asynchronously write javascript, even with document.write.\n * @version v2.0.8\n * @see {@link https://krux.github.io/postscribe}\n * @license MIT\n * @author Derek Brans\n * @copyright 2016 Krux Digital, Inc\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _postscribe = __webpack_require__(1);\n\t\n\tvar _postscribe2 = _interopRequireDefault(_postscribe);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tmodule.exports = _postscribe2['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\texports['default'] = postscribe;\n\t\n\tvar _writeStream = __webpack_require__(2);\n\t\n\tvar _writeStream2 = _interopRequireDefault(_writeStream);\n\t\n\tvar _utils = __webpack_require__(4);\n\t\n\tvar utils = _interopRequireWildcard(_utils);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t/**\n\t * A function that intentionally does nothing.\n\t */\n\tfunction doNothing() {}\n\t\n\t/**\n\t * Available options and defaults.\n\t *\n\t * @type {Object}\n\t */\n\tvar OPTIONS = {\n\t  /**\n\t   * Called when an async script has loaded.\n\t   */\n\t  afterAsync: doNothing,\n\t\n\t  /**\n\t   * Called immediately before removing from the write queue.\n\t   */\n\t  afterDequeue: doNothing,\n\t\n\t  /**\n\t   * Called sync after a stream's first thread release.\n\t   */\n\t  afterStreamStart: doNothing,\n\t\n\t  /**\n\t   * Called after writing buffered document.write calls.\n\t   */\n\t  afterWrite: doNothing,\n\t\n\t  /**\n\t   * Allows disabling the autoFix feature of prescribe\n\t   */\n\t  autoFix: true,\n\t\n\t  /**\n\t   * Called immediately before adding to the write queue.\n\t   */\n\t  beforeEnqueue: doNothing,\n\t\n\t  /**\n\t   * Called before writing a token.\n\t   *\n\t   * @param {Object} tok The token\n\t   */\n\t  beforeWriteToken: function beforeWriteToken(tok) {\n\t    return tok;\n\t  },\n\t\n\t  /**\n\t   * Called before writing buffered document.write calls.\n\t   *\n\t   * @param {String} str The string\n\t   */\n\t  beforeWrite: function beforeWrite(str) {\n\t    return str;\n\t  },\n\t\n\t  /**\n\t   * Called when evaluation is finished.\n\t   */\n\t  done: doNothing,\n\t\n\t  /**\n\t   * Called when a write results in an error.\n\t   *\n\t   * @param {Error} e The error\n\t   */\n\t  error: function error(e) {\n\t    throw new Error(e.msg);\n\t  },\n\t\n\t\n\t  /**\n\t   * Whether to let scripts w/ async attribute set fall out of the queue.\n\t   */\n\t  releaseAsync: false\n\t};\n\t\n\tvar nextId = 0;\n\tvar queue = [];\n\tvar active = null;\n\t\n\tfunction nextStream() {\n\t  var args = queue.shift();\n\t  if (args) {\n\t    var options = utils.last(args);\n\t\n\t    options.afterDequeue();\n\t    args.stream = runStream.apply(undefined, args);\n\t    options.afterStreamStart();\n\t  }\n\t}\n\t\n\tfunction runStream(el, html, options) {\n\t  active = new _writeStream2['default'](el, options);\n\t\n\t  // Identify this stream.\n\t  active.id = nextId++;\n\t  active.name = options.name || active.id;\n\t  postscribe.streams[active.name] = active;\n\t\n\t  // Override document.write.\n\t  var doc = el.ownerDocument;\n\t\n\t  var stash = {\n\t    close: doc.close,\n\t    open: doc.open,\n\t    write: doc.write,\n\t    writeln: doc.writeln\n\t  };\n\t\n\t  function _write(str) {\n\t    str = options.beforeWrite(str);\n\t    active.write(str);\n\t    options.afterWrite(str);\n\t  }\n\t\n\t  _extends(doc, {\n\t    close: doNothing,\n\t    open: doNothing,\n\t    write: function write() {\n\t      for (var _len = arguments.length, str = Array(_len), _key = 0; _key < _len; _key++) {\n\t        str[_key] = arguments[_key];\n\t      }\n\t\n\t      return _write(str.join(''));\n\t    },\n\t    writeln: function writeln() {\n\t      for (var _len2 = arguments.length, str = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t        str[_key2] = arguments[_key2];\n\t      }\n\t\n\t      return _write(str.join('') + '\\n');\n\t    }\n\t  });\n\t\n\t  // Override window.onerror\n\t  var oldOnError = active.win.onerror || doNothing;\n\t\n\t  // This works together with the try/catch around WriteStream::insertScript\n\t  // In modern browsers, exceptions in tag scripts go directly to top level\n\t  active.win.onerror = function (msg, url, line) {\n\t    options.error({ msg: msg + ' - ' + url + ': ' + line });\n\t    oldOnError.apply(active.win, [msg, url, line]);\n\t  };\n\t\n\t  // Write to the stream\n\t  active.write(html, function () {\n\t    // restore document.write\n\t    _extends(doc, stash);\n\t\n\t    // restore window.onerror\n\t    active.win.onerror = oldOnError;\n\t\n\t    options.done();\n\t    active = null;\n\t    nextStream();\n\t  });\n\t\n\t  return active;\n\t}\n\t\n\tfunction postscribe(el, html, options) {\n\t  if (utils.isFunction(options)) {\n\t    options = { done: options };\n\t  } else if (options === 'clear') {\n\t    queue = [];\n\t    active = null;\n\t    nextId = 0;\n\t    return;\n\t  }\n\t\n\t  options = utils.defaults(options, OPTIONS);\n\t\n\t  // id selector\n\t  if (/^#/.test(el)) {\n\t    el = window.document.getElementById(el.substr(1));\n\t  } else {\n\t    el = el.jquery ? el[0] : el;\n\t  }\n\t\n\t  var args = [el, html, options];\n\t\n\t  el.postscribe = {\n\t    cancel: function cancel() {\n\t      if (args.stream) {\n\t        args.stream.abort();\n\t      } else {\n\t        args[1] = doNothing;\n\t      }\n\t    }\n\t  };\n\t\n\t  options.beforeEnqueue(args);\n\t  queue.push(args);\n\t\n\t  if (!active) {\n\t    nextStream();\n\t  }\n\t\n\t  return el.postscribe;\n\t}\n\t\n\t_extends(postscribe, {\n\t  // Streams by name.\n\t  streams: {},\n\t  // Queue of streams.\n\t  queue: queue,\n\t  // Expose internal classes.\n\t  WriteStream: _writeStream2['default']\n\t});\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _prescribe = __webpack_require__(3);\n\t\n\tvar _prescribe2 = _interopRequireDefault(_prescribe);\n\t\n\tvar _utils = __webpack_require__(4);\n\t\n\tvar utils = _interopRequireWildcard(_utils);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Turn on to debug how each chunk affected the DOM.\n\t * @type {boolean}\n\t */\n\tvar DEBUG_CHUNK = false;\n\t\n\t/**\n\t * Prefix for data attributes on DOM elements.\n\t * @type {string}\n\t */\n\tvar BASEATTR = 'data-ps-';\n\t\n\t/**\n\t * ID for the style proxy\n\t * @type {string}\n\t */\n\tvar PROXY_STYLE = 'ps-style';\n\t\n\t/**\n\t * ID for the script proxy\n\t * @type {string}\n\t */\n\tvar PROXY_SCRIPT = 'ps-script';\n\t\n\t/**\n\t * Get data attributes\n\t *\n\t * @param {Object} el The DOM element.\n\t * @param {String} name The attribute name.\n\t * @returns {String}\n\t */\n\tfunction getData(el, name) {\n\t  var attr = BASEATTR + name;\n\t\n\t  var val = el.getAttribute(attr);\n\t\n\t  // IE 8 returns a number if it's a number\n\t  return !utils.existy(val) ? val : String(val);\n\t}\n\t\n\t/**\n\t * Set data attributes\n\t *\n\t * @param {Object} el The DOM element.\n\t * @param {String} name The attribute name.\n\t * @param {null|*} value The attribute value.\n\t */\n\tfunction setData(el, name) {\n\t  var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\n\t  var attr = BASEATTR + name;\n\t\n\t  if (utils.existy(value) && value !== '') {\n\t    el.setAttribute(attr, value);\n\t  } else {\n\t    el.removeAttribute(attr);\n\t  }\n\t}\n\t\n\t/**\n\t * Stream static html to an element, where \"static html\" denotes \"html\n\t * without scripts\".\n\t *\n\t * This class maintains a *history of writes devoid of any attributes* or\n\t * \"proxy history\".\n\t *\n\t * Injecting the proxy history into a temporary div has no side-effects,\n\t * other than to create proxy elements for previously written elements.\n\t *\n\t * Given the `staticHtml` of a new write, a `tempDiv`'s innerHTML is set to\n\t * `proxy_history + staticHtml`.\n\t * The *structure* of `tempDiv`'s contents, (i.e., the placement of new nodes\n\t * beside or inside of proxy elements), reflects the DOM structure that would\n\t * have resulted if all writes had been squashed into a single write.\n\t *\n\t * For each descendent `node` of `tempDiv` whose parentNode is a *proxy*,\n\t * `node` is appended to the corresponding *real* element within the DOM.\n\t *\n\t * Proxy elements are mapped to *actual* elements in the DOM by injecting a\n\t * `data-id` attribute into each start tag in `staticHtml`.\n\t *\n\t */\n\t\n\tvar WriteStream = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {Object} root The root element\n\t   * @param {?Object} options The options\n\t   */\n\t  function WriteStream(root) {\n\t    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t    _classCallCheck(this, WriteStream);\n\t\n\t    this.root = root;\n\t    this.options = options;\n\t    this.doc = root.ownerDocument;\n\t    this.win = this.doc.defaultView || this.doc.parentWindow;\n\t    this.parser = new _prescribe2['default']('', { autoFix: options.autoFix });\n\t\n\t    // Actual elements by id.\n\t    this.actuals = [root];\n\t\n\t    // Embodies the \"structure\" of what's been written so far,\n\t    // devoid of attributes.\n\t    this.proxyHistory = '';\n\t\n\t    // Create a proxy of the root element.\n\t    this.proxyRoot = this.doc.createElement(root.nodeName);\n\t\n\t    this.scriptStack = [];\n\t    this.writeQueue = [];\n\t\n\t    setData(this.proxyRoot, 'proxyof', 0);\n\t  }\n\t\n\t  /**\n\t   * Writes the given strings.\n\t   *\n\t   * @param {...String} str The strings to write\n\t   */\n\t\n\t\n\t  WriteStream.prototype.write = function write() {\n\t    var _writeQueue;\n\t\n\t    (_writeQueue = this.writeQueue).push.apply(_writeQueue, arguments);\n\t\n\t    // Process writes\n\t    // When new script gets pushed or pending this will stop\n\t    // because new writeQueue gets pushed\n\t    while (!this.deferredRemote && this.writeQueue.length) {\n\t      var arg = this.writeQueue.shift();\n\t\n\t      if (utils.isFunction(arg)) {\n\t        this._callFunction(arg);\n\t      } else {\n\t        this._writeImpl(arg);\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Calls the given function.\n\t   *\n\t   * @param {Function} fn The function to call\n\t   * @private\n\t   */\n\t\n\t\n\t  WriteStream.prototype._callFunction = function _callFunction(fn) {\n\t    var tok = { type: 'function', value: fn.name || fn.toString() };\n\t    this._onScriptStart(tok);\n\t    fn.call(this.win, this.doc);\n\t    this._onScriptDone(tok);\n\t  };\n\t\n\t  /**\n\t   * The write implementation\n\t   *\n\t   * @param {String} html The HTML to write.\n\t   * @private\n\t   */\n\t\n\t\n\t  WriteStream.prototype._writeImpl = function _writeImpl(html) {\n\t    this.parser.append(html);\n\t\n\t    var tok = void 0;\n\t    var script = void 0;\n\t    var style = void 0;\n\t    var tokens = [];\n\t\n\t    // stop if we see a script token\n\t    while ((tok = this.parser.readToken()) && !(script = utils.isScript(tok)) && !(style = utils.isStyle(tok))) {\n\t      tok = this.options.beforeWriteToken(tok);\n\t\n\t      if (tok) {\n\t        tokens.push(tok);\n\t      }\n\t    }\n\t\n\t    if (tokens.length > 0) {\n\t      this._writeStaticTokens(tokens);\n\t    }\n\t\n\t    if (script) {\n\t      this._handleScriptToken(tok);\n\t    }\n\t\n\t    if (style) {\n\t      this._handleStyleToken(tok);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Write contiguous non-script tokens (a chunk)\n\t   *\n\t   * @param {Array<Object>} tokens The tokens\n\t   * @returns {{tokens, raw, actual, proxy}|null}\n\t   * @private\n\t   */\n\t\n\t\n\t  WriteStream.prototype._writeStaticTokens = function _writeStaticTokens(tokens) {\n\t    var chunk = this._buildChunk(tokens);\n\t\n\t    if (!chunk.actual) {\n\t      // e.g., no tokens, or a noscript that got ignored\n\t      return null;\n\t    }\n\t\n\t    chunk.html = this.proxyHistory + chunk.actual;\n\t    this.proxyHistory += chunk.proxy;\n\t    this.proxyRoot.innerHTML = chunk.html;\n\t\n\t    if (DEBUG_CHUNK) {\n\t      chunk.proxyInnerHTML = this.proxyRoot.innerHTML;\n\t    }\n\t\n\t    this._walkChunk();\n\t\n\t    if (DEBUG_CHUNK) {\n\t      chunk.actualInnerHTML = this.root.innerHTML;\n\t    }\n\t\n\t    return chunk;\n\t  };\n\t\n\t  /**\n\t   * Build a chunk.\n\t   *\n\t   * @param {Array<Object>} tokens The tokens to use.\n\t   * @returns {{tokens: *, raw: string, actual: string, proxy: string}}\n\t   * @private\n\t   */\n\t\n\t\n\t  WriteStream.prototype._buildChunk = function _buildChunk(tokens) {\n\t    var nextId = this.actuals.length;\n\t\n\t    // The raw html of this chunk.\n\t    var raw = [];\n\t\n\t    // The html to create the nodes in the tokens (with id's injected).\n\t    var actual = [];\n\t\n\t    // Html that can later be used to proxy the nodes in the tokens.\n\t    var proxy = [];\n\t\n\t    var len = tokens.length;\n\t    for (var i = 0; i < len; i++) {\n\t      var tok = tokens[i];\n\t      var tokenRaw = tok.toString();\n\t\n\t      raw.push(tokenRaw);\n\t\n\t      if (tok.attrs) {\n\t        // tok.attrs <==> startTag or atomicTag or cursor\n\t        // Ignore noscript tags. They are atomic, so we don't have to worry about children.\n\t        if (!/^noscript$/i.test(tok.tagName)) {\n\t          var id = nextId++;\n\t\n\t          // Actual: inject id attribute: replace '>' at end of start tag with id attribute + '>'\n\t          actual.push(tokenRaw.replace(/(\\/?>)/, ' ' + BASEATTR + 'id=' + id + ' $1'));\n\t\n\t          // Don't proxy scripts: they have no bearing on DOM structure.\n\t          if (tok.attrs.id !== PROXY_SCRIPT && tok.attrs.id !== PROXY_STYLE) {\n\t            // Proxy: strip all attributes and inject proxyof attribute\n\t            proxy.push(\n\t            // ignore atomic tags (e.g., style): they have no \"structural\" effect\n\t            tok.type === 'atomicTag' ? '' : '<' + tok.tagName + ' ' + BASEATTR + 'proxyof=' + id + (tok.unary ? ' />' : '>'));\n\t          }\n\t        }\n\t      } else {\n\t        // Visit any other type of token\n\t        // Actual: append.\n\t        actual.push(tokenRaw);\n\t\n\t        // Proxy: append endTags. Ignore everything else.\n\t        proxy.push(tok.type === 'endTag' ? tokenRaw : '');\n\t      }\n\t    }\n\t\n\t    return {\n\t      tokens: tokens,\n\t      raw: raw.join(''),\n\t      actual: actual.join(''),\n\t      proxy: proxy.join('')\n\t    };\n\t  };\n\t\n\t  /**\n\t   * Walk the chunks.\n\t   *\n\t   * @private\n\t   */\n\t\n\t\n\t  WriteStream.prototype._walkChunk = function _walkChunk() {\n\t    var node = void 0;\n\t    var stack = [this.proxyRoot];\n\t\n\t    // use shift/unshift so that children are walked in document order\n\t    while (utils.existy(node = stack.shift())) {\n\t      var isElement = node.nodeType === 1;\n\t      var isProxy = isElement && getData(node, 'proxyof');\n\t\n\t      // Ignore proxies\n\t      if (!isProxy) {\n\t        if (isElement) {\n\t          // New actual element: register it and remove the the id attr.\n\t          this.actuals[getData(node, 'id')] = node;\n\t          setData(node, 'id');\n\t        }\n\t\n\t        // Is node's parent a proxy?\n\t        var parentIsProxyOf = node.parentNode && getData(node.parentNode, 'proxyof');\n\t        if (parentIsProxyOf) {\n\t          // Move node under actual parent.\n\t          this.actuals[parentIsProxyOf].appendChild(node);\n\t        }\n\t      }\n\t\n\t      // prepend childNodes to stack\n\t      stack.unshift.apply(stack, utils.toArray(node.childNodes));\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Handles Script tokens\n\t   *\n\t   * @param {Object} tok The token\n\t   */\n\t\n\t\n\t  WriteStream.prototype._handleScriptToken = function _handleScriptToken(tok) {\n\t    var _this = this;\n\t\n\t    var remainder = this.parser.clear();\n\t\n\t    if (remainder) {\n\t      // Write remainder immediately behind this script.\n\t      this.writeQueue.unshift(remainder);\n\t    }\n\t\n\t    tok.src = tok.attrs.src || tok.attrs.SRC;\n\t\n\t    tok = this.options.beforeWriteToken(tok);\n\t    if (!tok) {\n\t      // User has removed this token\n\t      return;\n\t    }\n\t\n\t    if (tok.src && this.scriptStack.length) {\n\t      // Defer this script until scriptStack is empty.\n\t      // Assumption 1: This script will not start executing until\n\t      // scriptStack is empty.\n\t      this.deferredRemote = tok;\n\t    } else {\n\t      this._onScriptStart(tok);\n\t    }\n\t\n\t    // Put the script node in the DOM.\n\t    this._writeScriptToken(tok, function () {\n\t      _this._onScriptDone(tok);\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Handles style tokens\n\t   *\n\t   * @param {Object} tok The token\n\t   */\n\t\n\t\n\t  WriteStream.prototype._handleStyleToken = function _handleStyleToken(tok) {\n\t    var remainder = this.parser.clear();\n\t\n\t    if (remainder) {\n\t      // Write remainder immediately behind this style.\n\t      this.writeQueue.unshift(remainder);\n\t    }\n\t\n\t    tok.type = tok.attrs.type || tok.attrs.TYPE || 'text/css';\n\t\n\t    tok = this.options.beforeWriteToken(tok);\n\t\n\t    if (tok) {\n\t      // Put the style node in the DOM.\n\t      this._writeStyleToken(tok);\n\t    }\n\t\n\t    if (remainder) {\n\t      this.write();\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Build a style and insert it into the DOM.\n\t   *\n\t   * @param {Object} tok The token\n\t   */\n\t\n\t\n\t  WriteStream.prototype._writeStyleToken = function _writeStyleToken(tok) {\n\t    var el = this._buildStyle(tok);\n\t\n\t    this._insertCursor(el, PROXY_STYLE);\n\t\n\t    // Set content\n\t    if (tok.content) {\n\t      if (el.styleSheet && !el.sheet) {\n\t        el.styleSheet.cssText = tok.content;\n\t      } else {\n\t        el.appendChild(this.doc.createTextNode(tok.content));\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Build a style element from an atomic style token.\n\t   *\n\t   * @param {Object} tok The token\n\t   * @returns {Element}\n\t   */\n\t\n\t\n\t  WriteStream.prototype._buildStyle = function _buildStyle(tok) {\n\t    var el = this.doc.createElement(tok.tagName);\n\t\n\t    el.setAttribute('type', tok.type);\n\t\n\t    // Set attributes\n\t    utils.eachKey(tok.attrs, function (name, value) {\n\t      el.setAttribute(name, value);\n\t    });\n\t\n\t    return el;\n\t  };\n\t\n\t  /**\n\t   * Append a span to the stream. That span will act as a cursor\n\t   * (i.e. insertion point) for the element.\n\t   *\n\t   * @param {Object} el The element\n\t   * @param {string} which The type of proxy element\n\t   */\n\t\n\t\n\t  WriteStream.prototype._insertCursor = function _insertCursor(el, which) {\n\t    this._writeImpl('<span id=\"' + which + '\"/>');\n\t\n\t    var cursor = this.doc.getElementById(which);\n\t\n\t    if (cursor) {\n\t      cursor.parentNode.replaceChild(el, cursor);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Called when a script is started.\n\t   *\n\t   * @param {Object} tok The token\n\t   * @private\n\t   */\n\t\n\t\n\t  WriteStream.prototype._onScriptStart = function _onScriptStart(tok) {\n\t    tok.outerWrites = this.writeQueue;\n\t    this.writeQueue = [];\n\t    this.scriptStack.unshift(tok);\n\t  };\n\t\n\t  /**\n\t   * Called when a script is done.\n\t   *\n\t   * @param {Object} tok The token\n\t   * @private\n\t   */\n\t\n\t\n\t  WriteStream.prototype._onScriptDone = function _onScriptDone(tok) {\n\t    // Pop script and check nesting.\n\t    if (tok !== this.scriptStack[0]) {\n\t      this.options.error({ msg: 'Bad script nesting or script finished twice' });\n\t      return;\n\t    }\n\t\n\t    this.scriptStack.shift();\n\t\n\t    // Append outer writes to queue and process them.\n\t    this.write.apply(this, tok.outerWrites);\n\t\n\t    // Check for pending remote\n\t\n\t    // Assumption 2: if remote_script1 writes remote_script2 then\n\t    // the we notice remote_script1 finishes before remote_script2 starts.\n\t    // I think this is equivalent to assumption 1\n\t    if (!this.scriptStack.length && this.deferredRemote) {\n\t      this._onScriptStart(this.deferredRemote);\n\t      this.deferredRemote = null;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Build a script and insert it into the DOM.\n\t   * Done is called once script has executed.\n\t   *\n\t   * @param {Object} tok The token\n\t   * @param {Function} done The callback when complete\n\t   */\n\t\n\t\n\t  WriteStream.prototype._writeScriptToken = function _writeScriptToken(tok, done) {\n\t    var el = this._buildScript(tok);\n\t    var asyncRelease = this._shouldRelease(el);\n\t    var afterAsync = this.options.afterAsync;\n\t\n\t    if (tok.src) {\n\t      // Fix for attribute \"SRC\" (capitalized). IE does not recognize it.\n\t      el.src = tok.src;\n\t      this._scriptLoadHandler(el, !asyncRelease ? function () {\n\t        done();\n\t        afterAsync();\n\t      } : afterAsync);\n\t    }\n\t\n\t    try {\n\t      this._insertCursor(el, PROXY_SCRIPT);\n\t      if (!el.src || asyncRelease) {\n\t        done();\n\t      }\n\t    } catch (e) {\n\t      this.options.error(e);\n\t      done();\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Build a script element from an atomic script token.\n\t   *\n\t   * @param {Object} tok The token\n\t   * @returns {Element}\n\t   */\n\t\n\t\n\t  WriteStream.prototype._buildScript = function _buildScript(tok) {\n\t    var el = this.doc.createElement(tok.tagName);\n\t\n\t    // Set attributes\n\t    utils.eachKey(tok.attrs, function (name, value) {\n\t      el.setAttribute(name, value);\n\t    });\n\t\n\t    // Set content\n\t    if (tok.content) {\n\t      el.text = tok.content;\n\t    }\n\t\n\t    return el;\n\t  };\n\t\n\t  /**\n\t   * Setup the script load handler on an element.\n\t   *\n\t   * @param {Object} el The element\n\t   * @param {Function} done The callback\n\t   * @private\n\t   */\n\t\n\t\n\t  WriteStream.prototype._scriptLoadHandler = function _scriptLoadHandler(el, done) {\n\t    function cleanup() {\n\t      el = el.onload = el.onreadystatechange = el.onerror = null;\n\t    }\n\t\n\t    var error = this.options.error;\n\t\n\t    function success() {\n\t      cleanup();\n\t      if (done != null) {\n\t        done();\n\t      }\n\t      done = null;\n\t    }\n\t\n\t    function failure(err) {\n\t      cleanup();\n\t      error(err);\n\t      if (done != null) {\n\t        done();\n\t      }\n\t      done = null;\n\t    }\n\t\n\t    function reattachEventListener(el, evt) {\n\t      var handler = el['on' + evt];\n\t      if (handler != null) {\n\t        el['_on' + evt] = handler;\n\t      }\n\t    }\n\t\n\t    reattachEventListener(el, 'load');\n\t    reattachEventListener(el, 'error');\n\t\n\t    _extends(el, {\n\t      onload: function onload() {\n\t        if (el._onload) {\n\t          try {\n\t            el._onload.apply(this, Array.prototype.slice.call(arguments, 0));\n\t          } catch (err) {\n\t            failure({ msg: 'onload handler failed ' + err + ' @ ' + el.src });\n\t          }\n\t        }\n\t        success();\n\t      },\n\t      onerror: function onerror() {\n\t        if (el._onerror) {\n\t          try {\n\t            el._onerror.apply(this, Array.prototype.slice.call(arguments, 0));\n\t          } catch (err) {\n\t            failure({ msg: 'onerror handler failed ' + err + ' @ ' + el.src });\n\t            return;\n\t          }\n\t        }\n\t        failure({ msg: 'remote script failed ' + el.src });\n\t      },\n\t      onreadystatechange: function onreadystatechange() {\n\t        if (/^(loaded|complete)$/.test(el.readyState)) {\n\t          success();\n\t        }\n\t      }\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Determines whether to release.\n\t   *\n\t   * @param {Object} el The element\n\t   * @returns {boolean}\n\t   * @private\n\t   */\n\t\n\t\n\t  WriteStream.prototype._shouldRelease = function _shouldRelease(el) {\n\t    var isScript = /^script$/i.test(el.nodeName);\n\t    return !isScript || !!(this.options.releaseAsync && el.src && el.hasAttribute('async'));\n\t  };\n\t\n\t  return WriteStream;\n\t}();\n\t\n\texports['default'] = WriteStream;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @file prescribe\n\t * @description Tiny, forgiving HTML parser\n\t * @version vundefined\n\t * @see {@link https://github.com/krux/prescribe/}\n\t * @license MIT\n\t * @author Derek Brans\n\t * @copyright 2016 Krux Digital, Inc\n\t */\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse {}\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tvar _HtmlParser = __webpack_require__(1);\n\t\n\t\tvar _HtmlParser2 = _interopRequireDefault(_HtmlParser);\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tmodule.exports = _HtmlParser2['default'];\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\texports.__esModule = true;\n\t\n\t\tvar _supports = __webpack_require__(2);\n\t\n\t\tvar supports = _interopRequireWildcard(_supports);\n\t\n\t\tvar _streamReaders = __webpack_require__(3);\n\t\n\t\tvar streamReaders = _interopRequireWildcard(_streamReaders);\n\t\n\t\tvar _fixedReadTokenFactory = __webpack_require__(6);\n\t\n\t\tvar _fixedReadTokenFactory2 = _interopRequireDefault(_fixedReadTokenFactory);\n\t\n\t\tvar _utils = __webpack_require__(5);\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\t\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t\t/**\n\t\t * Detection regular expressions.\n\t\t *\n\t\t * Order of detection matters: detection of one can only\n\t\t * succeed if detection of previous didn't\n\t\n\t\t * @type {Object}\n\t\t */\n\t\tvar detect = {\n\t\t  comment: /^<!--/,\n\t\t  endTag: /^<\\//,\n\t\t  atomicTag: /^<\\s*(script|style|noscript|iframe|textarea)[\\s\\/>]/i,\n\t\t  startTag: /^</,\n\t\t  chars: /^[^<]/\n\t\t};\n\t\n\t\t/**\n\t\t * HtmlParser provides the capability to parse HTML and return tokens\n\t\t * representing the tags and content.\n\t\t */\n\t\n\t\tvar HtmlParser = function () {\n\t\t  /**\n\t\t   * Constructor.\n\t\t   *\n\t\t   * @param {string} stream The initial parse stream contents.\n\t\t   * @param {Object} options The options\n\t\t   * @param {boolean} options.autoFix Set to true to automatically fix errors\n\t\t   */\n\t\t  function HtmlParser() {\n\t\t    var _this = this;\n\t\n\t\t    var stream = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\t\t    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t\t    _classCallCheck(this, HtmlParser);\n\t\n\t\t    this.stream = stream;\n\t\n\t\t    var fix = false;\n\t\t    var fixedTokenOptions = {};\n\t\n\t\t    for (var key in supports) {\n\t\t      if (supports.hasOwnProperty(key)) {\n\t\t        if (options.autoFix) {\n\t\t          fixedTokenOptions[key + 'Fix'] = true; // !supports[key];\n\t\t        }\n\t\t        fix = fix || fixedTokenOptions[key + 'Fix'];\n\t\t      }\n\t\t    }\n\t\n\t\t    if (fix) {\n\t\t      this._readToken = (0, _fixedReadTokenFactory2['default'])(this, fixedTokenOptions, function () {\n\t\t        return _this._readTokenImpl();\n\t\t      });\n\t\t      this._peekToken = (0, _fixedReadTokenFactory2['default'])(this, fixedTokenOptions, function () {\n\t\t        return _this._peekTokenImpl();\n\t\t      });\n\t\t    } else {\n\t\t      this._readToken = this._readTokenImpl;\n\t\t      this._peekToken = this._peekTokenImpl;\n\t\t    }\n\t\t  }\n\t\n\t\t  /**\n\t\t   * Appends the given string to the parse stream.\n\t\t   *\n\t\t   * @param {string} str The string to append\n\t\t   */\n\t\n\t\n\t\t  HtmlParser.prototype.append = function append(str) {\n\t\t    this.stream += str;\n\t\t  };\n\t\n\t\t  /**\n\t\t   * Prepends the given string to the parse stream.\n\t\t   *\n\t\t   * @param {string} str The string to prepend\n\t\t   */\n\t\n\t\n\t\t  HtmlParser.prototype.prepend = function prepend(str) {\n\t\t    this.stream = str + this.stream;\n\t\t  };\n\t\n\t\t  /**\n\t\t   * The implementation of the token reading.\n\t\t   *\n\t\t   * @private\n\t\t   * @returns {?Token}\n\t\t   */\n\t\n\t\n\t\t  HtmlParser.prototype._readTokenImpl = function _readTokenImpl() {\n\t\t    var token = this._peekTokenImpl();\n\t\t    if (token) {\n\t\t      this.stream = this.stream.slice(token.length);\n\t\t      return token;\n\t\t    }\n\t\t  };\n\t\n\t\t  /**\n\t\t   * The implementation of token peeking.\n\t\t   *\n\t\t   * @returns {?Token}\n\t\t   */\n\t\n\t\n\t\t  HtmlParser.prototype._peekTokenImpl = function _peekTokenImpl() {\n\t\t    for (var type in detect) {\n\t\t      if (detect.hasOwnProperty(type)) {\n\t\t        if (detect[type].test(this.stream)) {\n\t\t          var token = streamReaders[type](this.stream);\n\t\n\t\t          if (token) {\n\t\t            if (token.type === 'startTag' && /script|style/i.test(token.tagName)) {\n\t\t              return null;\n\t\t            } else {\n\t\t              token.text = this.stream.substr(0, token.length);\n\t\t              return token;\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  };\n\t\n\t\t  /**\n\t\t   * The public token peeking interface.  Delegates to the basic token peeking\n\t\t   * or a version that performs fixups depending on the `autoFix` setting in\n\t\t   * options.\n\t\t   *\n\t\t   * @returns {object}\n\t\t   */\n\t\n\t\n\t\t  HtmlParser.prototype.peekToken = function peekToken() {\n\t\t    return this._peekToken();\n\t\t  };\n\t\n\t\t  /**\n\t\t   * The public token reading interface.  Delegates to the basic token reading\n\t\t   * or a version that performs fixups depending on the `autoFix` setting in\n\t\t   * options.\n\t\t   *\n\t\t   * @returns {object}\n\t\t   */\n\t\n\t\n\t\t  HtmlParser.prototype.readToken = function readToken() {\n\t\t    return this._readToken();\n\t\t  };\n\t\n\t\t  /**\n\t\t   * Read tokens and hand to the given handlers.\n\t\t   *\n\t\t   * @param {Object} handlers The handlers to use for the different tokens.\n\t\t   */\n\t\n\t\n\t\t  HtmlParser.prototype.readTokens = function readTokens(handlers) {\n\t\t    var tok = void 0;\n\t\t    while (tok = this.readToken()) {\n\t\t      // continue until we get an explicit \"false\" return\n\t\t      if (handlers[tok.type] && handlers[tok.type](tok) === false) {\n\t\t        return;\n\t\t      }\n\t\t    }\n\t\t  };\n\t\n\t\t  /**\n\t\t   * Clears the parse stream.\n\t\t   *\n\t\t   * @returns {string} The contents of the parse stream before clearing.\n\t\t   */\n\t\n\t\n\t\t  HtmlParser.prototype.clear = function clear() {\n\t\t    var rest = this.stream;\n\t\t    this.stream = '';\n\t\t    return rest;\n\t\t  };\n\t\n\t\t  /**\n\t\t   * Returns the rest of the parse stream.\n\t\t   *\n\t\t   * @returns {string} The contents of the parse stream.\n\t\t   */\n\t\n\t\n\t\t  HtmlParser.prototype.rest = function rest() {\n\t\t    return this.stream;\n\t\t  };\n\t\n\t\t  return HtmlParser;\n\t\t}();\n\t\n\t\texports['default'] = HtmlParser;\n\t\n\t\n\t\tHtmlParser.tokenToString = function (tok) {\n\t\t  return tok.toString();\n\t\t};\n\t\n\t\tHtmlParser.escapeAttributes = function (attrs) {\n\t\t  var escapedAttrs = {};\n\t\n\t\t  for (var name in attrs) {\n\t\t    if (attrs.hasOwnProperty(name)) {\n\t\t      escapedAttrs[name] = (0, _utils.escapeQuotes)(attrs[name], null);\n\t\t    }\n\t\t  }\n\t\n\t\t  return escapedAttrs;\n\t\t};\n\t\n\t\tHtmlParser.supports = supports;\n\t\n\t\tfor (var key in supports) {\n\t\t  if (supports.hasOwnProperty(key)) {\n\t\t    HtmlParser.browserHasFlaw = HtmlParser.browserHasFlaw || !supports[key] && key;\n\t\t  }\n\t\t}\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\texports.__esModule = true;\n\t\tvar tagSoup = false;\n\t\tvar selfClose = false;\n\t\n\t\tvar work = window.document.createElement('div');\n\t\n\t\ttry {\n\t\t  var html = '<P><I></P></I>';\n\t\t  work.innerHTML = html;\n\t\t  exports.tagSoup = tagSoup = work.innerHTML !== html;\n\t\t} catch (e) {\n\t\t  exports.tagSoup = tagSoup = false;\n\t\t}\n\t\n\t\ttry {\n\t\t  work.innerHTML = '<P><i><P></P></i></P>';\n\t\t  exports.selfClose = selfClose = work.childNodes.length === 2;\n\t\t} catch (e) {\n\t\t  exports.selfClose = selfClose = false;\n\t\t}\n\t\n\t\twork = null;\n\t\n\t\texports.tagSoup = tagSoup;\n\t\texports.selfClose = selfClose;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\texports.__esModule = true;\n\t\n\t\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t\texports.comment = comment;\n\t\texports.chars = chars;\n\t\texports.startTag = startTag;\n\t\texports.atomicTag = atomicTag;\n\t\texports.endTag = endTag;\n\t\n\t\tvar _tokens = __webpack_require__(4);\n\t\n\t\t/**\n\t\t * Regular Expressions for parsing tags and attributes\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tvar REGEXES = {\n\t\t  startTag: /^<([\\-A-Za-z0-9_]+)((?:\\s+[\\w\\-]+(?:\\s*=?\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/,\n\t\t  endTag: /^<\\/([\\-A-Za-z0-9_]+)[^>]*>/,\n\t\t  attr: /(?:([\\-A-Za-z0-9_]+)\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|([^>\\s]+)))|(?:([\\-A-Za-z0-9_]+)(\\s|$)+)/g,\n\t\t  fillAttr: /^(checked|compact|declare|defer|disabled|ismap|multiple|nohref|noresize|noshade|nowrap|readonly|selected)$/i\n\t\t};\n\t\n\t\t/**\n\t\t * Reads a comment token\n\t\t *\n\t\t * @param {string} stream The input stream\n\t\t * @returns {CommentToken}\n\t\t */\n\t\tfunction comment(stream) {\n\t\t  var index = stream.indexOf('-->');\n\t\t  if (index >= 0) {\n\t\t    return new _tokens.CommentToken(stream.substr(4, index - 1), index + 3);\n\t\t  }\n\t\t}\n\t\n\t\t/**\n\t\t * Reads non-tag characters.\n\t\t *\n\t\t * @param {string} stream The input stream\n\t\t * @returns {CharsToken}\n\t\t */\n\t\tfunction chars(stream) {\n\t\t  var index = stream.indexOf('<');\n\t\t  return new _tokens.CharsToken(index >= 0 ? index : stream.length);\n\t\t}\n\t\n\t\t/**\n\t\t * Reads start tag token.\n\t\t *\n\t\t * @param {string} stream The input stream\n\t\t * @returns {StartTagToken}\n\t\t */\n\t\tfunction startTag(stream) {\n\t\t  var endTagIndex = stream.indexOf('>');\n\t\t  if (endTagIndex !== -1) {\n\t\t    var match = stream.match(REGEXES.startTag);\n\t\t    if (match) {\n\t\t      var _ret = function () {\n\t\t        var attrs = {};\n\t\t        var booleanAttrs = {};\n\t\t        var rest = match[2];\n\t\n\t\t        match[2].replace(REGEXES.attr, function (match, name) {\n\t\t          if (!(arguments[2] || arguments[3] || arguments[4] || arguments[5])) {\n\t\t            attrs[name] = '';\n\t\t          } else if (arguments[5]) {\n\t\t            attrs[arguments[5]] = '';\n\t\t            booleanAttrs[arguments[5]] = true;\n\t\t          } else {\n\t\t            attrs[name] = arguments[2] || arguments[3] || arguments[4] || REGEXES.fillAttr.test(name) && name || '';\n\t\t          }\n\t\n\t\t          rest = rest.replace(match, '');\n\t\t        });\n\t\n\t\t        return {\n\t\t          v: new _tokens.StartTagToken(match[1], match[0].length, attrs, booleanAttrs, !!match[3], rest.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, ''))\n\t\t        };\n\t\t      }();\n\t\n\t\t      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t\t    }\n\t\t  }\n\t\t}\n\t\n\t\t/**\n\t\t * Reads atomic tag token.\n\t\t *\n\t\t * @param {string} stream The input stream\n\t\t * @returns {AtomicTagToken}\n\t\t */\n\t\tfunction atomicTag(stream) {\n\t\t  var start = startTag(stream);\n\t\t  if (start) {\n\t\t    var rest = stream.slice(start.length);\n\t\t    // for optimization, we check first just for the end tag\n\t\t    if (rest.match(new RegExp('<\\/\\\\s*' + start.tagName + '\\\\s*>', 'i'))) {\n\t\t      // capturing the content is inefficient, so we do it inside the if\n\t\t      var match = rest.match(new RegExp('([\\\\s\\\\S]*?)<\\/\\\\s*' + start.tagName + '\\\\s*>', 'i'));\n\t\t      if (match) {\n\t\t        return new _tokens.AtomicTagToken(start.tagName, match[0].length + start.length, start.attrs, start.booleanAttrs, match[1]);\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t\n\t\t/**\n\t\t * Reads an end tag token.\n\t\t *\n\t\t * @param {string} stream The input stream\n\t\t * @returns {EndTagToken}\n\t\t */\n\t\tfunction endTag(stream) {\n\t\t  var match = stream.match(REGEXES.endTag);\n\t\t  if (match) {\n\t\t    return new _tokens.EndTagToken(match[1], match[0].length);\n\t\t  }\n\t\t}\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\texports.__esModule = true;\n\t\texports.EndTagToken = exports.AtomicTagToken = exports.StartTagToken = exports.TagToken = exports.CharsToken = exports.CommentToken = exports.Token = undefined;\n\t\n\t\tvar _utils = __webpack_require__(5);\n\t\n\t\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t\t/**\n\t\t * Token is a base class for all token types parsed.  Note we don't actually\n\t\t * use intheritance due to IE8's non-existent ES5 support.\n\t\t */\n\t\tvar Token =\n\t\t/**\n\t\t * Constructor.\n\t\t *\n\t\t * @param {string} type The type of the Token.\n\t\t * @param {Number} length The length of the Token text.\n\t\t */\n\t\texports.Token = function Token(type, length) {\n\t\t  _classCallCheck(this, Token);\n\t\n\t\t  this.type = type;\n\t\t  this.length = length;\n\t\t  this.text = '';\n\t\t};\n\t\n\t\t/**\n\t\t * CommentToken represents comment tags.\n\t\t */\n\t\n\t\n\t\tvar CommentToken = exports.CommentToken = function () {\n\t\t  /**\n\t\t   * Constructor.\n\t\t   *\n\t\t   * @param {string} content The content of the comment\n\t\t   * @param {Number} length The length of the Token text.\n\t\t   */\n\t\t  function CommentToken(content, length) {\n\t\t    _classCallCheck(this, CommentToken);\n\t\n\t\t    this.type = 'comment';\n\t\t    this.length = length || (content ? content.length : 0);\n\t\t    this.text = '';\n\t\t    this.content = content;\n\t\t  }\n\t\n\t\t  CommentToken.prototype.toString = function toString() {\n\t\t    return '<!--' + this.content;\n\t\t  };\n\t\n\t\t  return CommentToken;\n\t\t}();\n\t\n\t\t/**\n\t\t * CharsToken represents non-tag characters.\n\t\t */\n\t\n\t\n\t\tvar CharsToken = exports.CharsToken = function () {\n\t\t  /**\n\t\t   * Constructor.\n\t\t   *\n\t\t   * @param {Number} length The length of the Token text.\n\t\t   */\n\t\t  function CharsToken(length) {\n\t\t    _classCallCheck(this, CharsToken);\n\t\n\t\t    this.type = 'chars';\n\t\t    this.length = length;\n\t\t    this.text = '';\n\t\t  }\n\t\n\t\t  CharsToken.prototype.toString = function toString() {\n\t\t    return this.text;\n\t\t  };\n\t\n\t\t  return CharsToken;\n\t\t}();\n\t\n\t\t/**\n\t\t * TagToken is a base class for all tag-based Tokens.\n\t\t */\n\t\n\t\n\t\tvar TagToken = exports.TagToken = function () {\n\t\t  /**\n\t\t   * Constructor.\n\t\t   *\n\t\t   * @param {string} type The type of the token.\n\t\t   * @param {string} tagName The tag name.\n\t\t   * @param {Number} length The length of the Token text.\n\t\t   * @param {Object} attrs The dictionary of attributes and values\n\t\t   * @param {Object} booleanAttrs If an entry has 'true' then the attribute\n\t\t   *                              is a boolean attribute\n\t\t   */\n\t\t  function TagToken(type, tagName, length, attrs, booleanAttrs) {\n\t\t    _classCallCheck(this, TagToken);\n\t\n\t\t    this.type = type;\n\t\t    this.length = length;\n\t\t    this.text = '';\n\t\t    this.tagName = tagName;\n\t\t    this.attrs = attrs;\n\t\t    this.booleanAttrs = booleanAttrs;\n\t\t    this.unary = false;\n\t\t    this.html5Unary = false;\n\t\t  }\n\t\n\t\t  /**\n\t\t   * Formats the given token tag.\n\t\t   *\n\t\t   * @param {TagToken} tok The TagToken to format.\n\t\t   * @param {?string} [content=null] The content of the token.\n\t\t   * @returns {string} The formatted tag.\n\t\t   */\n\t\n\t\n\t\t  TagToken.formatTag = function formatTag(tok) {\n\t\t    var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t\t    var str = '<' + tok.tagName;\n\t\t    for (var key in tok.attrs) {\n\t\t      if (tok.attrs.hasOwnProperty(key)) {\n\t\t        str += ' ' + key;\n\t\n\t\t        var val = tok.attrs[key];\n\t\t        if (typeof tok.booleanAttrs === 'undefined' || typeof tok.booleanAttrs[key] === 'undefined') {\n\t\t          str += '=\"' + (0, _utils.escapeQuotes)(val) + '\"';\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    if (tok.rest) {\n\t\t      str += ' ' + tok.rest;\n\t\t    }\n\t\n\t\t    if (tok.unary && !tok.html5Unary) {\n\t\t      str += '/>';\n\t\t    } else {\n\t\t      str += '>';\n\t\t    }\n\t\n\t\t    if (content !== undefined && content !== null) {\n\t\t      str += content + '</' + tok.tagName + '>';\n\t\t    }\n\t\n\t\t    return str;\n\t\t  };\n\t\n\t\t  return TagToken;\n\t\t}();\n\t\n\t\t/**\n\t\t * StartTagToken represents a start token.\n\t\t */\n\t\n\t\n\t\tvar StartTagToken = exports.StartTagToken = function () {\n\t\t  /**\n\t\t   * Constructor.\n\t\t   *\n\t\t   * @param {string} tagName The tag name.\n\t\t   * @param {Number} length The length of the Token text\n\t\t   * @param {Object} attrs The dictionary of attributes and values\n\t\t   * @param {Object} booleanAttrs If an entry has 'true' then the attribute\n\t\t   *                              is a boolean attribute\n\t\t   * @param {boolean} unary True if the tag is a unary tag\n\t\t   * @param {string} rest The rest of the content.\n\t\t   */\n\t\t  function StartTagToken(tagName, length, attrs, booleanAttrs, unary, rest) {\n\t\t    _classCallCheck(this, StartTagToken);\n\t\n\t\t    this.type = 'startTag';\n\t\t    this.length = length;\n\t\t    this.text = '';\n\t\t    this.tagName = tagName;\n\t\t    this.attrs = attrs;\n\t\t    this.booleanAttrs = booleanAttrs;\n\t\t    this.html5Unary = false;\n\t\t    this.unary = unary;\n\t\t    this.rest = rest;\n\t\t  }\n\t\n\t\t  StartTagToken.prototype.toString = function toString() {\n\t\t    return TagToken.formatTag(this);\n\t\t  };\n\t\n\t\t  return StartTagToken;\n\t\t}();\n\t\n\t\t/**\n\t\t * AtomicTagToken represents an atomic tag.\n\t\t */\n\t\n\t\n\t\tvar AtomicTagToken = exports.AtomicTagToken = function () {\n\t\t  /**\n\t\t   * Constructor.\n\t\t   *\n\t\t   * @param {string} tagName The name of the tag.\n\t\t   * @param {Number} length The length of the tag text.\n\t\t   * @param {Object} attrs The attributes.\n\t\t   * @param {Object} booleanAttrs If an entry has 'true' then the attribute\n\t\t   *                              is a boolean attribute\n\t\t   * @param {string} content The content of the tag.\n\t\t   */\n\t\t  function AtomicTagToken(tagName, length, attrs, booleanAttrs, content) {\n\t\t    _classCallCheck(this, AtomicTagToken);\n\t\n\t\t    this.type = 'atomicTag';\n\t\t    this.length = length;\n\t\t    this.text = '';\n\t\t    this.tagName = tagName;\n\t\t    this.attrs = attrs;\n\t\t    this.booleanAttrs = booleanAttrs;\n\t\t    this.unary = false;\n\t\t    this.html5Unary = false;\n\t\t    this.content = content;\n\t\t  }\n\t\n\t\t  AtomicTagToken.prototype.toString = function toString() {\n\t\t    return TagToken.formatTag(this, this.content);\n\t\t  };\n\t\n\t\t  return AtomicTagToken;\n\t\t}();\n\t\n\t\t/**\n\t\t * EndTagToken represents an end tag.\n\t\t */\n\t\n\t\n\t\tvar EndTagToken = exports.EndTagToken = function () {\n\t\t  /**\n\t\t   * Constructor.\n\t\t   *\n\t\t   * @param {string} tagName The name of the tag.\n\t\t   * @param {Number} length The length of the tag text.\n\t\t   */\n\t\t  function EndTagToken(tagName, length) {\n\t\t    _classCallCheck(this, EndTagToken);\n\t\n\t\t    this.type = 'endTag';\n\t\t    this.length = length;\n\t\t    this.text = '';\n\t\t    this.tagName = tagName;\n\t\t  }\n\t\n\t\t  EndTagToken.prototype.toString = function toString() {\n\t\t    return '</' + this.tagName + '>';\n\t\t  };\n\t\n\t\t  return EndTagToken;\n\t\t}();\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\texports.__esModule = true;\n\t\texports.escapeQuotes = escapeQuotes;\n\t\n\t\t/**\n\t\t * Escape quotes in the given value.\n\t\t *\n\t\t * @param {string} value The value to escape.\n\t\t * @param {string} [defaultValue=''] The default value to return if value is falsy.\n\t\t * @returns {string}\n\t\t */\n\t\tfunction escapeQuotes(value) {\n\t\t  var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\t\n\t\t  // There's no lookback in JS, so /(^|[^\\\\])\"/ only matches the first of two `\"`s.\n\t\t  // Instead, just match anything before a double-quote and escape if it's not already escaped.\n\t\t  return !value ? defaultValue : value.replace(/([^\"]*)\"/g, function (_, prefix) {\n\t\t    return (/\\\\/.test(prefix) ? prefix + '\"' : prefix + '\\\\\"'\n\t\t    );\n\t\t  });\n\t\t}\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\texports.__esModule = true;\n\t\texports['default'] = fixedReadTokenFactory;\n\t\t/**\n\t\t * Empty Elements - HTML 4.01\n\t\t *\n\t\t * @type {RegExp}\n\t\t */\n\t\tvar EMPTY = /^(AREA|BASE|BASEFONT|BR|COL|FRAME|HR|IMG|INPUT|ISINDEX|LINK|META|PARAM|EMBED)$/i;\n\t\n\t\t/**\n\t\t * Elements that you can intentionally leave open (and which close themselves)\n\t\t *\n\t\t * @type {RegExp}\n\t\t */\n\t\tvar CLOSESELF = /^(COLGROUP|DD|DT|LI|OPTIONS|P|TD|TFOOT|TH|THEAD|TR)$/i;\n\t\n\t\t/**\n\t\t * Corrects a token.\n\t\t *\n\t\t * @param {Token} tok The token to correct\n\t\t * @returns {Token} The corrected token\n\t\t */\n\t\tfunction correct(tok) {\n\t\t  if (tok && tok.type === 'startTag') {\n\t\t    tok.unary = EMPTY.test(tok.tagName) || tok.unary;\n\t\t    tok.html5Unary = !/\\/>$/.test(tok.text);\n\t\t  }\n\t\t  return tok;\n\t\t}\n\t\n\t\t/**\n\t\t * Peeks at the next token in the parser.\n\t\t *\n\t\t * @param {HtmlParser} parser The parser\n\t\t * @param {Function} readTokenImpl The underlying readToken implementation\n\t\t * @returns {Token} The next token\n\t\t */\n\t\tfunction peekToken(parser, readTokenImpl) {\n\t\t  var tmp = parser.stream;\n\t\t  var tok = correct(readTokenImpl());\n\t\t  parser.stream = tmp;\n\t\t  return tok;\n\t\t}\n\t\n\t\t/**\n\t\t * Closes the last token.\n\t\t *\n\t\t * @param {HtmlParser} parser The parser\n\t\t * @param {Array<Token>} stack The stack\n\t\t */\n\t\tfunction closeLast(parser, stack) {\n\t\t  var tok = stack.pop();\n\t\n\t\t  // prepend close tag to stream.\n\t\t  parser.prepend('</' + tok.tagName + '>');\n\t\t}\n\t\n\t\t/**\n\t\t * Create a new token stack.\n\t\t *\n\t\t * @returns {Array<Token>}\n\t\t */\n\t\tfunction newStack() {\n\t\t  var stack = [];\n\t\n\t\t  stack.last = function () {\n\t\t    return this[this.length - 1];\n\t\t  };\n\t\n\t\t  stack.lastTagNameEq = function (tagName) {\n\t\t    var last = this.last();\n\t\t    return last && last.tagName && last.tagName.toUpperCase() === tagName.toUpperCase();\n\t\t  };\n\t\n\t\t  stack.containsTagName = function (tagName) {\n\t\t    for (var i = 0, tok; tok = this[i]; i++) {\n\t\t      if (tok.tagName === tagName) {\n\t\t        return true;\n\t\t      }\n\t\t    }\n\t\t    return false;\n\t\t  };\n\t\n\t\t  return stack;\n\t\t}\n\t\n\t\t/**\n\t\t * Return a readToken implementation that fixes input.\n\t\t *\n\t\t * @param {HtmlParser} parser The parser\n\t\t * @param {Object} options Options for fixing\n\t\t * @param {boolean} options.tagSoupFix True to fix tag soup scenarios\n\t\t * @param {boolean} options.selfCloseFix True to fix self-closing tags\n\t\t * @param {Function} readTokenImpl The underlying readToken implementation\n\t\t * @returns {Function}\n\t\t */\n\t\tfunction fixedReadTokenFactory(parser, options, readTokenImpl) {\n\t\t  var stack = newStack();\n\t\n\t\t  var handlers = {\n\t\t    startTag: function startTag(tok) {\n\t\t      var tagName = tok.tagName;\n\t\n\t\t      if (tagName.toUpperCase() === 'TR' && stack.lastTagNameEq('TABLE')) {\n\t\t        parser.prepend('<TBODY>');\n\t\t        prepareNextToken();\n\t\t      } else if (options.selfCloseFix && CLOSESELF.test(tagName) && stack.containsTagName(tagName)) {\n\t\t        if (stack.lastTagNameEq(tagName)) {\n\t\t          closeLast(parser, stack);\n\t\t        } else {\n\t\t          parser.prepend('</' + tok.tagName + '>');\n\t\t          prepareNextToken();\n\t\t        }\n\t\t      } else if (!tok.unary) {\n\t\t        stack.push(tok);\n\t\t      }\n\t\t    },\n\t\t    endTag: function endTag(tok) {\n\t\t      var last = stack.last();\n\t\t      if (last) {\n\t\t        if (options.tagSoupFix && !stack.lastTagNameEq(tok.tagName)) {\n\t\t          // cleanup tag soup\n\t\t          closeLast(parser, stack);\n\t\t        } else {\n\t\t          stack.pop();\n\t\t        }\n\t\t      } else if (options.tagSoupFix) {\n\t\t        // cleanup tag soup part 2: skip this token\n\t\t        readTokenImpl();\n\t\t        prepareNextToken();\n\t\t      }\n\t\t    }\n\t\t  };\n\t\n\t\t  function prepareNextToken() {\n\t\t    var tok = peekToken(parser, readTokenImpl);\n\t\t    if (tok && handlers[tok.type]) {\n\t\t      handlers[tok.type](tok);\n\t\t    }\n\t\t  }\n\t\n\t\t  return function fixedReadToken() {\n\t\t    prepareNextToken();\n\t\t    return correct(readTokenImpl());\n\t\t  };\n\t\t}\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\texports.existy = existy;\n\texports.isFunction = isFunction;\n\texports.each = each;\n\texports.eachKey = eachKey;\n\texports.defaults = defaults;\n\texports.toArray = toArray;\n\texports.last = last;\n\texports.isTag = isTag;\n\texports.isScript = isScript;\n\texports.isStyle = isStyle;\n\t/**\n\t * Determine if the thing is not undefined and not null.\n\t *\n\t * @param {*} thing The thing to test\n\t * @returns {boolean} True if the thing is not undefined and not null.\n\t */\n\tfunction existy(thing) {\n\t  return thing !== void 0 && thing !== null;\n\t}\n\t\n\t/**\n\t * Is this a function?\n\t *\n\t * @param {*} x The variable to test\n\t * @returns {boolean} True if the variable is a function\n\t */\n\tfunction isFunction(x) {\n\t  return 'function' === typeof x;\n\t}\n\t\n\t/**\n\t * Loop over each item in an array-like value.\n\t *\n\t * @param {Array<*>} arr The array to loop over\n\t * @param {Function} fn The function to call\n\t * @param {?Object} target The object to bind to the function\n\t */\n\tfunction each(arr, fn, target) {\n\t  var i = void 0;\n\t  var len = arr && arr.length || 0;\n\t  for (i = 0; i < len; i++) {\n\t    fn.call(target, arr[i], i);\n\t  }\n\t}\n\t\n\t/**\n\t * Loop over each key/value pair in a hash.\n\t *\n\t * @param {Object} obj The object\n\t * @param {Function} fn The function to call\n\t * @param {?Object} target The object to bind to the function\n\t */\n\tfunction eachKey(obj, fn, target) {\n\t  for (var key in obj) {\n\t    if (obj.hasOwnProperty(key)) {\n\t      fn.call(target, key, obj[key]);\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Set default options where some option was not specified.\n\t *\n\t * @param {Object} options The destination\n\t * @param {Object} _defaults The defaults\n\t * @returns {Object}\n\t */\n\tfunction defaults(options, _defaults) {\n\t  options = options || {};\n\t  eachKey(_defaults, function (key, val) {\n\t    if (!existy(options[key])) {\n\t      options[key] = val;\n\t    }\n\t  });\n\t  return options;\n\t}\n\t\n\t/**\n\t * Convert value (e.g., a NodeList) to an array.\n\t *\n\t * @param {*} obj The object\n\t * @returns {Array<*>}\n\t */\n\tfunction toArray(obj) {\n\t  try {\n\t    return Array.prototype.slice.call(obj);\n\t  } catch (e) {\n\t    var _ret = function () {\n\t      var ret = [];\n\t      each(obj, function (val) {\n\t        ret.push(val);\n\t      });\n\t      return {\n\t        v: ret\n\t      };\n\t    }();\n\t\n\t    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t  }\n\t}\n\t\n\t/**\n\t * Get the last item in an array\n\t *\n\t * @param {Array<*>} array The array\n\t * @returns {*} The last item in the array\n\t */\n\tfunction last(array) {\n\t  return array[array.length - 1];\n\t}\n\t\n\t/**\n\t * Test if token is a script tag.\n\t *\n\t * @param {Object} tok The token\n\t * @param {String} tag The tag name\n\t * @returns {boolean} True if the token is a script tag\n\t */\n\tfunction isTag(tok, tag) {\n\t  return !tok || !(tok.type === 'startTag' || tok.type === 'atomicTag') || !('tagName' in tok) ? !1 : !!~tok.tagName.toLowerCase().indexOf(tag);\n\t}\n\t\n\t/**\n\t * Test if token is a script tag.\n\t *\n\t * @param {Object} tok The token\n\t * @returns {boolean} True if the token is a script tag\n\t */\n\tfunction isScript(tok) {\n\t  return isTag(tok, 'script');\n\t}\n\t\n\t/**\n\t * Test if token is a style tag.\n\t *\n\t * @param {Object} tok The token\n\t * @returns {boolean} True if the token is a style tag\n\t */\n\tfunction isStyle(tok) {\n\t  return isTag(tok, 'style');\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=postscribe.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9zdHNjcmliZS9kaXN0L3Bvc3RzY3JpYmUuanM/ZjAyMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLMkI7QUFDakMsQ0FBQztBQUNELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDLGtCQUFrQjs7QUFFaEc7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0RBQW9ELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCwyQkFBMkIsRUFBRSxFQUFFLEVBQUUsZUFBZTs7QUFFL1A7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDLDZCQUE2QixZQUFZLEVBQUUsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1Qiw0RUFBNEUsRUFBRSxFQUFFLHlCQUF5QixlQUFlLEVBQUU7O0FBRS9RLHVDQUF1Qyx1Q0FBdUMsa0JBQWtCOztBQUVoRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxFQUFFO0FBQ2QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wb3N0c2NyaWJlL2Rpc3QvcG9zdHNjcmliZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgcG9zdHNjcmliZVxuICogQGRlc2NyaXB0aW9uIEFzeW5jaHJvbm91c2x5IHdyaXRlIGphdmFzY3JpcHQsIGV2ZW4gd2l0aCBkb2N1bWVudC53cml0ZS5cbiAqIEB2ZXJzaW9uIHYyLjAuOFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9rcnV4LmdpdGh1Yi5pby9wb3N0c2NyaWJlfVxuICogQGxpY2Vuc2UgTUlUXG4gKiBAYXV0aG9yIERlcmVrIEJyYW5zXG4gKiBAY29weXJpZ2h0IDIwMTYgS3J1eCBEaWdpdGFsLCBJbmNcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wicG9zdHNjcmliZVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJwb3N0c2NyaWJlXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgX3Bvc3RzY3JpYmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcblx0dmFyIF9wb3N0c2NyaWJlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3RzY3JpYmUpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBfcG9zdHNjcmliZTJbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdFxuXHR2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXHRcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gcG9zdHNjcmliZTtcblx0XG5cdHZhciBfd3JpdGVTdHJlYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcblx0dmFyIF93cml0ZVN0cmVhbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93cml0ZVN0cmVhbSk7XG5cdFxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdHZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXHRcblx0LyoqXG5cdCAqIEEgZnVuY3Rpb24gdGhhdCBpbnRlbnRpb25hbGx5IGRvZXMgbm90aGluZy5cblx0ICovXG5cdGZ1bmN0aW9uIGRvTm90aGluZygpIHt9XG5cdFxuXHQvKipcblx0ICogQXZhaWxhYmxlIG9wdGlvbnMgYW5kIGRlZmF1bHRzLlxuXHQgKlxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKi9cblx0dmFyIE9QVElPTlMgPSB7XG5cdCAgLyoqXG5cdCAgICogQ2FsbGVkIHdoZW4gYW4gYXN5bmMgc2NyaXB0IGhhcyBsb2FkZWQuXG5cdCAgICovXG5cdCAgYWZ0ZXJBc3luYzogZG9Ob3RoaW5nLFxuXHRcblx0ICAvKipcblx0ICAgKiBDYWxsZWQgaW1tZWRpYXRlbHkgYmVmb3JlIHJlbW92aW5nIGZyb20gdGhlIHdyaXRlIHF1ZXVlLlxuXHQgICAqL1xuXHQgIGFmdGVyRGVxdWV1ZTogZG9Ob3RoaW5nLFxuXHRcblx0ICAvKipcblx0ICAgKiBDYWxsZWQgc3luYyBhZnRlciBhIHN0cmVhbSdzIGZpcnN0IHRocmVhZCByZWxlYXNlLlxuXHQgICAqL1xuXHQgIGFmdGVyU3RyZWFtU3RhcnQ6IGRvTm90aGluZyxcblx0XG5cdCAgLyoqXG5cdCAgICogQ2FsbGVkIGFmdGVyIHdyaXRpbmcgYnVmZmVyZWQgZG9jdW1lbnQud3JpdGUgY2FsbHMuXG5cdCAgICovXG5cdCAgYWZ0ZXJXcml0ZTogZG9Ob3RoaW5nLFxuXHRcblx0ICAvKipcblx0ICAgKiBBbGxvd3MgZGlzYWJsaW5nIHRoZSBhdXRvRml4IGZlYXR1cmUgb2YgcHJlc2NyaWJlXG5cdCAgICovXG5cdCAgYXV0b0ZpeDogdHJ1ZSxcblx0XG5cdCAgLyoqXG5cdCAgICogQ2FsbGVkIGltbWVkaWF0ZWx5IGJlZm9yZSBhZGRpbmcgdG8gdGhlIHdyaXRlIHF1ZXVlLlxuXHQgICAqL1xuXHQgIGJlZm9yZUVucXVldWU6IGRvTm90aGluZyxcblx0XG5cdCAgLyoqXG5cdCAgICogQ2FsbGVkIGJlZm9yZSB3cml0aW5nIGEgdG9rZW4uXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gdG9rIFRoZSB0b2tlblxuXHQgICAqL1xuXHQgIGJlZm9yZVdyaXRlVG9rZW46IGZ1bmN0aW9uIGJlZm9yZVdyaXRlVG9rZW4odG9rKSB7XG5cdCAgICByZXR1cm4gdG9rO1xuXHQgIH0sXG5cdFxuXHQgIC8qKlxuXHQgICAqIENhbGxlZCBiZWZvcmUgd3JpdGluZyBidWZmZXJlZCBkb2N1bWVudC53cml0ZSBjYWxscy5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZ1xuXHQgICAqL1xuXHQgIGJlZm9yZVdyaXRlOiBmdW5jdGlvbiBiZWZvcmVXcml0ZShzdHIpIHtcblx0ICAgIHJldHVybiBzdHI7XG5cdCAgfSxcblx0XG5cdCAgLyoqXG5cdCAgICogQ2FsbGVkIHdoZW4gZXZhbHVhdGlvbiBpcyBmaW5pc2hlZC5cblx0ICAgKi9cblx0ICBkb25lOiBkb05vdGhpbmcsXG5cdFxuXHQgIC8qKlxuXHQgICAqIENhbGxlZCB3aGVuIGEgd3JpdGUgcmVzdWx0cyBpbiBhbiBlcnJvci5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7RXJyb3J9IGUgVGhlIGVycm9yXG5cdCAgICovXG5cdCAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKGUpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcihlLm1zZyk7XG5cdCAgfSxcblx0XG5cdFxuXHQgIC8qKlxuXHQgICAqIFdoZXRoZXIgdG8gbGV0IHNjcmlwdHMgdy8gYXN5bmMgYXR0cmlidXRlIHNldCBmYWxsIG91dCBvZiB0aGUgcXVldWUuXG5cdCAgICovXG5cdCAgcmVsZWFzZUFzeW5jOiBmYWxzZVxuXHR9O1xuXHRcblx0dmFyIG5leHRJZCA9IDA7XG5cdHZhciBxdWV1ZSA9IFtdO1xuXHR2YXIgYWN0aXZlID0gbnVsbDtcblx0XG5cdGZ1bmN0aW9uIG5leHRTdHJlYW0oKSB7XG5cdCAgdmFyIGFyZ3MgPSBxdWV1ZS5zaGlmdCgpO1xuXHQgIGlmIChhcmdzKSB7XG5cdCAgICB2YXIgb3B0aW9ucyA9IHV0aWxzLmxhc3QoYXJncyk7XG5cdFxuXHQgICAgb3B0aW9ucy5hZnRlckRlcXVldWUoKTtcblx0ICAgIGFyZ3Muc3RyZWFtID0gcnVuU3RyZWFtLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG5cdCAgICBvcHRpb25zLmFmdGVyU3RyZWFtU3RhcnQoKTtcblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHJ1blN0cmVhbShlbCwgaHRtbCwgb3B0aW9ucykge1xuXHQgIGFjdGl2ZSA9IG5ldyBfd3JpdGVTdHJlYW0yWydkZWZhdWx0J10oZWwsIG9wdGlvbnMpO1xuXHRcblx0ICAvLyBJZGVudGlmeSB0aGlzIHN0cmVhbS5cblx0ICBhY3RpdmUuaWQgPSBuZXh0SWQrKztcblx0ICBhY3RpdmUubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBhY3RpdmUuaWQ7XG5cdCAgcG9zdHNjcmliZS5zdHJlYW1zW2FjdGl2ZS5uYW1lXSA9IGFjdGl2ZTtcblx0XG5cdCAgLy8gT3ZlcnJpZGUgZG9jdW1lbnQud3JpdGUuXG5cdCAgdmFyIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQ7XG5cdFxuXHQgIHZhciBzdGFzaCA9IHtcblx0ICAgIGNsb3NlOiBkb2MuY2xvc2UsXG5cdCAgICBvcGVuOiBkb2Mub3Blbixcblx0ICAgIHdyaXRlOiBkb2Mud3JpdGUsXG5cdCAgICB3cml0ZWxuOiBkb2Mud3JpdGVsblxuXHQgIH07XG5cdFxuXHQgIGZ1bmN0aW9uIF93cml0ZShzdHIpIHtcblx0ICAgIHN0ciA9IG9wdGlvbnMuYmVmb3JlV3JpdGUoc3RyKTtcblx0ICAgIGFjdGl2ZS53cml0ZShzdHIpO1xuXHQgICAgb3B0aW9ucy5hZnRlcldyaXRlKHN0cik7XG5cdCAgfVxuXHRcblx0ICBfZXh0ZW5kcyhkb2MsIHtcblx0ICAgIGNsb3NlOiBkb05vdGhpbmcsXG5cdCAgICBvcGVuOiBkb05vdGhpbmcsXG5cdCAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7XG5cdCAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdHIgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0ICAgICAgICBzdHJbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHJldHVybiBfd3JpdGUoc3RyLmpvaW4oJycpKTtcblx0ICAgIH0sXG5cdCAgICB3cml0ZWxuOiBmdW5jdGlvbiB3cml0ZWxuKCkge1xuXHQgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0ciA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG5cdCAgICAgICAgc3RyW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHJldHVybiBfd3JpdGUoc3RyLmpvaW4oJycpICsgJ1xcbicpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICAvLyBPdmVycmlkZSB3aW5kb3cub25lcnJvclxuXHQgIHZhciBvbGRPbkVycm9yID0gYWN0aXZlLndpbi5vbmVycm9yIHx8IGRvTm90aGluZztcblx0XG5cdCAgLy8gVGhpcyB3b3JrcyB0b2dldGhlciB3aXRoIHRoZSB0cnkvY2F0Y2ggYXJvdW5kIFdyaXRlU3RyZWFtOjppbnNlcnRTY3JpcHRcblx0ICAvLyBJbiBtb2Rlcm4gYnJvd3NlcnMsIGV4Y2VwdGlvbnMgaW4gdGFnIHNjcmlwdHMgZ28gZGlyZWN0bHkgdG8gdG9wIGxldmVsXG5cdCAgYWN0aXZlLndpbi5vbmVycm9yID0gZnVuY3Rpb24gKG1zZywgdXJsLCBsaW5lKSB7XG5cdCAgICBvcHRpb25zLmVycm9yKHsgbXNnOiBtc2cgKyAnIC0gJyArIHVybCArICc6ICcgKyBsaW5lIH0pO1xuXHQgICAgb2xkT25FcnJvci5hcHBseShhY3RpdmUud2luLCBbbXNnLCB1cmwsIGxpbmVdKTtcblx0ICB9O1xuXHRcblx0ICAvLyBXcml0ZSB0byB0aGUgc3RyZWFtXG5cdCAgYWN0aXZlLndyaXRlKGh0bWwsIGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIHJlc3RvcmUgZG9jdW1lbnQud3JpdGVcblx0ICAgIF9leHRlbmRzKGRvYywgc3Rhc2gpO1xuXHRcblx0ICAgIC8vIHJlc3RvcmUgd2luZG93Lm9uZXJyb3Jcblx0ICAgIGFjdGl2ZS53aW4ub25lcnJvciA9IG9sZE9uRXJyb3I7XG5cdFxuXHQgICAgb3B0aW9ucy5kb25lKCk7XG5cdCAgICBhY3RpdmUgPSBudWxsO1xuXHQgICAgbmV4dFN0cmVhbSgpO1xuXHQgIH0pO1xuXHRcblx0ICByZXR1cm4gYWN0aXZlO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBwb3N0c2NyaWJlKGVsLCBodG1sLCBvcHRpb25zKSB7XG5cdCAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ob3B0aW9ucykpIHtcblx0ICAgIG9wdGlvbnMgPSB7IGRvbmU6IG9wdGlvbnMgfTtcblx0ICB9IGVsc2UgaWYgKG9wdGlvbnMgPT09ICdjbGVhcicpIHtcblx0ICAgIHF1ZXVlID0gW107XG5cdCAgICBhY3RpdmUgPSBudWxsO1xuXHQgICAgbmV4dElkID0gMDtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdFxuXHQgIG9wdGlvbnMgPSB1dGlscy5kZWZhdWx0cyhvcHRpb25zLCBPUFRJT05TKTtcblx0XG5cdCAgLy8gaWQgc2VsZWN0b3Jcblx0ICBpZiAoL14jLy50ZXN0KGVsKSkge1xuXHQgICAgZWwgPSB3aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwuc3Vic3RyKDEpKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgZWwgPSBlbC5qcXVlcnkgPyBlbFswXSA6IGVsO1xuXHQgIH1cblx0XG5cdCAgdmFyIGFyZ3MgPSBbZWwsIGh0bWwsIG9wdGlvbnNdO1xuXHRcblx0ICBlbC5wb3N0c2NyaWJlID0ge1xuXHQgICAgY2FuY2VsOiBmdW5jdGlvbiBjYW5jZWwoKSB7XG5cdCAgICAgIGlmIChhcmdzLnN0cmVhbSkge1xuXHQgICAgICAgIGFyZ3Muc3RyZWFtLmFib3J0KCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgYXJnc1sxXSA9IGRvTm90aGluZztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIG9wdGlvbnMuYmVmb3JlRW5xdWV1ZShhcmdzKTtcblx0ICBxdWV1ZS5wdXNoKGFyZ3MpO1xuXHRcblx0ICBpZiAoIWFjdGl2ZSkge1xuXHQgICAgbmV4dFN0cmVhbSgpO1xuXHQgIH1cblx0XG5cdCAgcmV0dXJuIGVsLnBvc3RzY3JpYmU7XG5cdH1cblx0XG5cdF9leHRlbmRzKHBvc3RzY3JpYmUsIHtcblx0ICAvLyBTdHJlYW1zIGJ5IG5hbWUuXG5cdCAgc3RyZWFtczoge30sXG5cdCAgLy8gUXVldWUgb2Ygc3RyZWFtcy5cblx0ICBxdWV1ZTogcXVldWUsXG5cdCAgLy8gRXhwb3NlIGludGVybmFsIGNsYXNzZXMuXG5cdCAgV3JpdGVTdHJlYW06IF93cml0ZVN0cmVhbTJbJ2RlZmF1bHQnXVxuXHR9KTtcblxuLyoqKi8gfSxcbi8qIDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdFxuXHR2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXHRcblx0dmFyIF9wcmVzY3JpYmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRcblx0dmFyIF9wcmVzY3JpYmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJlc2NyaWJlKTtcblx0XG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcblx0dmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0LyoqXG5cdCAqIFR1cm4gb24gdG8gZGVidWcgaG93IGVhY2ggY2h1bmsgYWZmZWN0ZWQgdGhlIERPTS5cblx0ICogQHR5cGUge2Jvb2xlYW59XG5cdCAqL1xuXHR2YXIgREVCVUdfQ0hVTksgPSBmYWxzZTtcblx0XG5cdC8qKlxuXHQgKiBQcmVmaXggZm9yIGRhdGEgYXR0cmlidXRlcyBvbiBET00gZWxlbWVudHMuXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHR2YXIgQkFTRUFUVFIgPSAnZGF0YS1wcy0nO1xuXHRcblx0LyoqXG5cdCAqIElEIGZvciB0aGUgc3R5bGUgcHJveHlcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdHZhciBQUk9YWV9TVFlMRSA9ICdwcy1zdHlsZSc7XG5cdFxuXHQvKipcblx0ICogSUQgZm9yIHRoZSBzY3JpcHQgcHJveHlcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdHZhciBQUk9YWV9TQ1JJUFQgPSAncHMtc2NyaXB0Jztcblx0XG5cdC8qKlxuXHQgKiBHZXQgZGF0YSBhdHRyaWJ1dGVzXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlbCBUaGUgRE9NIGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZS5cblx0ICogQHJldHVybnMge1N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIGdldERhdGEoZWwsIG5hbWUpIHtcblx0ICB2YXIgYXR0ciA9IEJBU0VBVFRSICsgbmFtZTtcblx0XG5cdCAgdmFyIHZhbCA9IGVsLmdldEF0dHJpYnV0ZShhdHRyKTtcblx0XG5cdCAgLy8gSUUgOCByZXR1cm5zIGEgbnVtYmVyIGlmIGl0J3MgYSBudW1iZXJcblx0ICByZXR1cm4gIXV0aWxzLmV4aXN0eSh2YWwpID8gdmFsIDogU3RyaW5nKHZhbCk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBTZXQgZGF0YSBhdHRyaWJ1dGVzXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlbCBUaGUgRE9NIGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZS5cblx0ICogQHBhcmFtIHtudWxsfCp9IHZhbHVlIFRoZSBhdHRyaWJ1dGUgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBzZXREYXRhKGVsLCBuYW1lKSB7XG5cdCAgdmFyIHZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuXHRcblx0ICB2YXIgYXR0ciA9IEJBU0VBVFRSICsgbmFtZTtcblx0XG5cdCAgaWYgKHV0aWxzLmV4aXN0eSh2YWx1ZSkgJiYgdmFsdWUgIT09ICcnKSB7XG5cdCAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG5cdCAgfVxuXHR9XG5cdFxuXHQvKipcblx0ICogU3RyZWFtIHN0YXRpYyBodG1sIHRvIGFuIGVsZW1lbnQsIHdoZXJlIFwic3RhdGljIGh0bWxcIiBkZW5vdGVzIFwiaHRtbFxuXHQgKiB3aXRob3V0IHNjcmlwdHNcIi5cblx0ICpcblx0ICogVGhpcyBjbGFzcyBtYWludGFpbnMgYSAqaGlzdG9yeSBvZiB3cml0ZXMgZGV2b2lkIG9mIGFueSBhdHRyaWJ1dGVzKiBvclxuXHQgKiBcInByb3h5IGhpc3RvcnlcIi5cblx0ICpcblx0ICogSW5qZWN0aW5nIHRoZSBwcm94eSBoaXN0b3J5IGludG8gYSB0ZW1wb3JhcnkgZGl2IGhhcyBubyBzaWRlLWVmZmVjdHMsXG5cdCAqIG90aGVyIHRoYW4gdG8gY3JlYXRlIHByb3h5IGVsZW1lbnRzIGZvciBwcmV2aW91c2x5IHdyaXR0ZW4gZWxlbWVudHMuXG5cdCAqXG5cdCAqIEdpdmVuIHRoZSBgc3RhdGljSHRtbGAgb2YgYSBuZXcgd3JpdGUsIGEgYHRlbXBEaXZgJ3MgaW5uZXJIVE1MIGlzIHNldCB0b1xuXHQgKiBgcHJveHlfaGlzdG9yeSArIHN0YXRpY0h0bWxgLlxuXHQgKiBUaGUgKnN0cnVjdHVyZSogb2YgYHRlbXBEaXZgJ3MgY29udGVudHMsIChpLmUuLCB0aGUgcGxhY2VtZW50IG9mIG5ldyBub2Rlc1xuXHQgKiBiZXNpZGUgb3IgaW5zaWRlIG9mIHByb3h5IGVsZW1lbnRzKSwgcmVmbGVjdHMgdGhlIERPTSBzdHJ1Y3R1cmUgdGhhdCB3b3VsZFxuXHQgKiBoYXZlIHJlc3VsdGVkIGlmIGFsbCB3cml0ZXMgaGFkIGJlZW4gc3F1YXNoZWQgaW50byBhIHNpbmdsZSB3cml0ZS5cblx0ICpcblx0ICogRm9yIGVhY2ggZGVzY2VuZGVudCBgbm9kZWAgb2YgYHRlbXBEaXZgIHdob3NlIHBhcmVudE5vZGUgaXMgYSAqcHJveHkqLFxuXHQgKiBgbm9kZWAgaXMgYXBwZW5kZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgKnJlYWwqIGVsZW1lbnQgd2l0aGluIHRoZSBET00uXG5cdCAqXG5cdCAqIFByb3h5IGVsZW1lbnRzIGFyZSBtYXBwZWQgdG8gKmFjdHVhbCogZWxlbWVudHMgaW4gdGhlIERPTSBieSBpbmplY3RpbmcgYVxuXHQgKiBgZGF0YS1pZGAgYXR0cmlidXRlIGludG8gZWFjaCBzdGFydCB0YWcgaW4gYHN0YXRpY0h0bWxgLlxuXHQgKlxuXHQgKi9cblx0XG5cdHZhciBXcml0ZVN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcblx0ICAvKipcblx0ICAgKiBDb25zdHJ1Y3Rvci5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSByb290IFRoZSByb290IGVsZW1lbnRcblx0ICAgKiBAcGFyYW0gez9PYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnNcblx0ICAgKi9cblx0ICBmdW5jdGlvbiBXcml0ZVN0cmVhbShyb290KSB7XG5cdCAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cdFxuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdyaXRlU3RyZWFtKTtcblx0XG5cdCAgICB0aGlzLnJvb3QgPSByb290O1xuXHQgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0ICAgIHRoaXMuZG9jID0gcm9vdC5vd25lckRvY3VtZW50O1xuXHQgICAgdGhpcy53aW4gPSB0aGlzLmRvYy5kZWZhdWx0VmlldyB8fCB0aGlzLmRvYy5wYXJlbnRXaW5kb3c7XG5cdCAgICB0aGlzLnBhcnNlciA9IG5ldyBfcHJlc2NyaWJlMlsnZGVmYXVsdCddKCcnLCB7IGF1dG9GaXg6IG9wdGlvbnMuYXV0b0ZpeCB9KTtcblx0XG5cdCAgICAvLyBBY3R1YWwgZWxlbWVudHMgYnkgaWQuXG5cdCAgICB0aGlzLmFjdHVhbHMgPSBbcm9vdF07XG5cdFxuXHQgICAgLy8gRW1ib2RpZXMgdGhlIFwic3RydWN0dXJlXCIgb2Ygd2hhdCdzIGJlZW4gd3JpdHRlbiBzbyBmYXIsXG5cdCAgICAvLyBkZXZvaWQgb2YgYXR0cmlidXRlcy5cblx0ICAgIHRoaXMucHJveHlIaXN0b3J5ID0gJyc7XG5cdFxuXHQgICAgLy8gQ3JlYXRlIGEgcHJveHkgb2YgdGhlIHJvb3QgZWxlbWVudC5cblx0ICAgIHRoaXMucHJveHlSb290ID0gdGhpcy5kb2MuY3JlYXRlRWxlbWVudChyb290Lm5vZGVOYW1lKTtcblx0XG5cdCAgICB0aGlzLnNjcmlwdFN0YWNrID0gW107XG5cdCAgICB0aGlzLndyaXRlUXVldWUgPSBbXTtcblx0XG5cdCAgICBzZXREYXRhKHRoaXMucHJveHlSb290LCAncHJveHlvZicsIDApO1xuXHQgIH1cblx0XG5cdCAgLyoqXG5cdCAgICogV3JpdGVzIHRoZSBnaXZlbiBzdHJpbmdzLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHsuLi5TdHJpbmd9IHN0ciBUaGUgc3RyaW5ncyB0byB3cml0ZVxuXHQgICAqL1xuXHRcblx0XG5cdCAgV3JpdGVTdHJlYW0ucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUoKSB7XG5cdCAgICB2YXIgX3dyaXRlUXVldWU7XG5cdFxuXHQgICAgKF93cml0ZVF1ZXVlID0gdGhpcy53cml0ZVF1ZXVlKS5wdXNoLmFwcGx5KF93cml0ZVF1ZXVlLCBhcmd1bWVudHMpO1xuXHRcblx0ICAgIC8vIFByb2Nlc3Mgd3JpdGVzXG5cdCAgICAvLyBXaGVuIG5ldyBzY3JpcHQgZ2V0cyBwdXNoZWQgb3IgcGVuZGluZyB0aGlzIHdpbGwgc3RvcFxuXHQgICAgLy8gYmVjYXVzZSBuZXcgd3JpdGVRdWV1ZSBnZXRzIHB1c2hlZFxuXHQgICAgd2hpbGUgKCF0aGlzLmRlZmVycmVkUmVtb3RlICYmIHRoaXMud3JpdGVRdWV1ZS5sZW5ndGgpIHtcblx0ICAgICAgdmFyIGFyZyA9IHRoaXMud3JpdGVRdWV1ZS5zaGlmdCgpO1xuXHRcblx0ICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24oYXJnKSkge1xuXHQgICAgICAgIHRoaXMuX2NhbGxGdW5jdGlvbihhcmcpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuX3dyaXRlSW1wbChhcmcpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgLyoqXG5cdCAgICogQ2FsbHMgdGhlIGdpdmVuIGZ1bmN0aW9uLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGxcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqL1xuXHRcblx0XG5cdCAgV3JpdGVTdHJlYW0ucHJvdG90eXBlLl9jYWxsRnVuY3Rpb24gPSBmdW5jdGlvbiBfY2FsbEZ1bmN0aW9uKGZuKSB7XG5cdCAgICB2YXIgdG9rID0geyB0eXBlOiAnZnVuY3Rpb24nLCB2YWx1ZTogZm4ubmFtZSB8fCBmbi50b1N0cmluZygpIH07XG5cdCAgICB0aGlzLl9vblNjcmlwdFN0YXJ0KHRvayk7XG5cdCAgICBmbi5jYWxsKHRoaXMud2luLCB0aGlzLmRvYyk7XG5cdCAgICB0aGlzLl9vblNjcmlwdERvbmUodG9rKTtcblx0ICB9O1xuXHRcblx0ICAvKipcblx0ICAgKiBUaGUgd3JpdGUgaW1wbGVtZW50YXRpb25cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIFRoZSBIVE1MIHRvIHdyaXRlLlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cdFxuXHRcblx0ICBXcml0ZVN0cmVhbS5wcm90b3R5cGUuX3dyaXRlSW1wbCA9IGZ1bmN0aW9uIF93cml0ZUltcGwoaHRtbCkge1xuXHQgICAgdGhpcy5wYXJzZXIuYXBwZW5kKGh0bWwpO1xuXHRcblx0ICAgIHZhciB0b2sgPSB2b2lkIDA7XG5cdCAgICB2YXIgc2NyaXB0ID0gdm9pZCAwO1xuXHQgICAgdmFyIHN0eWxlID0gdm9pZCAwO1xuXHQgICAgdmFyIHRva2VucyA9IFtdO1xuXHRcblx0ICAgIC8vIHN0b3AgaWYgd2Ugc2VlIGEgc2NyaXB0IHRva2VuXG5cdCAgICB3aGlsZSAoKHRvayA9IHRoaXMucGFyc2VyLnJlYWRUb2tlbigpKSAmJiAhKHNjcmlwdCA9IHV0aWxzLmlzU2NyaXB0KHRvaykpICYmICEoc3R5bGUgPSB1dGlscy5pc1N0eWxlKHRvaykpKSB7XG5cdCAgICAgIHRvayA9IHRoaXMub3B0aW9ucy5iZWZvcmVXcml0ZVRva2VuKHRvayk7XG5cdFxuXHQgICAgICBpZiAodG9rKSB7XG5cdCAgICAgICAgdG9rZW5zLnB1c2godG9rKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCkge1xuXHQgICAgICB0aGlzLl93cml0ZVN0YXRpY1Rva2Vucyh0b2tlbnMpO1xuXHQgICAgfVxuXHRcblx0ICAgIGlmIChzY3JpcHQpIHtcblx0ICAgICAgdGhpcy5faGFuZGxlU2NyaXB0VG9rZW4odG9rKTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAoc3R5bGUpIHtcblx0ICAgICAgdGhpcy5faGFuZGxlU3R5bGVUb2tlbih0b2spO1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIC8qKlxuXHQgICAqIFdyaXRlIGNvbnRpZ3VvdXMgbm9uLXNjcmlwdCB0b2tlbnMgKGEgY2h1bmspXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHRva2VucyBUaGUgdG9rZW5zXG5cdCAgICogQHJldHVybnMge3t0b2tlbnMsIHJhdywgYWN0dWFsLCBwcm94eX18bnVsbH1cblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqL1xuXHRcblx0XG5cdCAgV3JpdGVTdHJlYW0ucHJvdG90eXBlLl93cml0ZVN0YXRpY1Rva2VucyA9IGZ1bmN0aW9uIF93cml0ZVN0YXRpY1Rva2Vucyh0b2tlbnMpIHtcblx0ICAgIHZhciBjaHVuayA9IHRoaXMuX2J1aWxkQ2h1bmsodG9rZW5zKTtcblx0XG5cdCAgICBpZiAoIWNodW5rLmFjdHVhbCkge1xuXHQgICAgICAvLyBlLmcuLCBubyB0b2tlbnMsIG9yIGEgbm9zY3JpcHQgdGhhdCBnb3QgaWdub3JlZFxuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0XG5cdCAgICBjaHVuay5odG1sID0gdGhpcy5wcm94eUhpc3RvcnkgKyBjaHVuay5hY3R1YWw7XG5cdCAgICB0aGlzLnByb3h5SGlzdG9yeSArPSBjaHVuay5wcm94eTtcblx0ICAgIHRoaXMucHJveHlSb290LmlubmVySFRNTCA9IGNodW5rLmh0bWw7XG5cdFxuXHQgICAgaWYgKERFQlVHX0NIVU5LKSB7XG5cdCAgICAgIGNodW5rLnByb3h5SW5uZXJIVE1MID0gdGhpcy5wcm94eVJvb3QuaW5uZXJIVE1MO1xuXHQgICAgfVxuXHRcblx0ICAgIHRoaXMuX3dhbGtDaHVuaygpO1xuXHRcblx0ICAgIGlmIChERUJVR19DSFVOSykge1xuXHQgICAgICBjaHVuay5hY3R1YWxJbm5lckhUTUwgPSB0aGlzLnJvb3QuaW5uZXJIVE1MO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiBjaHVuaztcblx0ICB9O1xuXHRcblx0ICAvKipcblx0ICAgKiBCdWlsZCBhIGNodW5rLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSB0b2tlbnMgVGhlIHRva2VucyB0byB1c2UuXG5cdCAgICogQHJldHVybnMge3t0b2tlbnM6ICosIHJhdzogc3RyaW5nLCBhY3R1YWw6IHN0cmluZywgcHJveHk6IHN0cmluZ319XG5cdCAgICogQHByaXZhdGVcblx0ICAgKi9cblx0XG5cdFxuXHQgIFdyaXRlU3RyZWFtLnByb3RvdHlwZS5fYnVpbGRDaHVuayA9IGZ1bmN0aW9uIF9idWlsZENodW5rKHRva2Vucykge1xuXHQgICAgdmFyIG5leHRJZCA9IHRoaXMuYWN0dWFscy5sZW5ndGg7XG5cdFxuXHQgICAgLy8gVGhlIHJhdyBodG1sIG9mIHRoaXMgY2h1bmsuXG5cdCAgICB2YXIgcmF3ID0gW107XG5cdFxuXHQgICAgLy8gVGhlIGh0bWwgdG8gY3JlYXRlIHRoZSBub2RlcyBpbiB0aGUgdG9rZW5zICh3aXRoIGlkJ3MgaW5qZWN0ZWQpLlxuXHQgICAgdmFyIGFjdHVhbCA9IFtdO1xuXHRcblx0ICAgIC8vIEh0bWwgdGhhdCBjYW4gbGF0ZXIgYmUgdXNlZCB0byBwcm94eSB0aGUgbm9kZXMgaW4gdGhlIHRva2Vucy5cblx0ICAgIHZhciBwcm94eSA9IFtdO1xuXHRcblx0ICAgIHZhciBsZW4gPSB0b2tlbnMubGVuZ3RoO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICB2YXIgdG9rID0gdG9rZW5zW2ldO1xuXHQgICAgICB2YXIgdG9rZW5SYXcgPSB0b2sudG9TdHJpbmcoKTtcblx0XG5cdCAgICAgIHJhdy5wdXNoKHRva2VuUmF3KTtcblx0XG5cdCAgICAgIGlmICh0b2suYXR0cnMpIHtcblx0ICAgICAgICAvLyB0b2suYXR0cnMgPD09PiBzdGFydFRhZyBvciBhdG9taWNUYWcgb3IgY3Vyc29yXG5cdCAgICAgICAgLy8gSWdub3JlIG5vc2NyaXB0IHRhZ3MuIFRoZXkgYXJlIGF0b21pYywgc28gd2UgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCBjaGlsZHJlbi5cblx0ICAgICAgICBpZiAoIS9ebm9zY3JpcHQkL2kudGVzdCh0b2sudGFnTmFtZSkpIHtcblx0ICAgICAgICAgIHZhciBpZCA9IG5leHRJZCsrO1xuXHRcblx0ICAgICAgICAgIC8vIEFjdHVhbDogaW5qZWN0IGlkIGF0dHJpYnV0ZTogcmVwbGFjZSAnPicgYXQgZW5kIG9mIHN0YXJ0IHRhZyB3aXRoIGlkIGF0dHJpYnV0ZSArICc+J1xuXHQgICAgICAgICAgYWN0dWFsLnB1c2godG9rZW5SYXcucmVwbGFjZSgvKFxcLz8+KS8sICcgJyArIEJBU0VBVFRSICsgJ2lkPScgKyBpZCArICcgJDEnKSk7XG5cdFxuXHQgICAgICAgICAgLy8gRG9uJ3QgcHJveHkgc2NyaXB0czogdGhleSBoYXZlIG5vIGJlYXJpbmcgb24gRE9NIHN0cnVjdHVyZS5cblx0ICAgICAgICAgIGlmICh0b2suYXR0cnMuaWQgIT09IFBST1hZX1NDUklQVCAmJiB0b2suYXR0cnMuaWQgIT09IFBST1hZX1NUWUxFKSB7XG5cdCAgICAgICAgICAgIC8vIFByb3h5OiBzdHJpcCBhbGwgYXR0cmlidXRlcyBhbmQgaW5qZWN0IHByb3h5b2YgYXR0cmlidXRlXG5cdCAgICAgICAgICAgIHByb3h5LnB1c2goXG5cdCAgICAgICAgICAgIC8vIGlnbm9yZSBhdG9taWMgdGFncyAoZS5nLiwgc3R5bGUpOiB0aGV5IGhhdmUgbm8gXCJzdHJ1Y3R1cmFsXCIgZWZmZWN0XG5cdCAgICAgICAgICAgIHRvay50eXBlID09PSAnYXRvbWljVGFnJyA/ICcnIDogJzwnICsgdG9rLnRhZ05hbWUgKyAnICcgKyBCQVNFQVRUUiArICdwcm94eW9mPScgKyBpZCArICh0b2sudW5hcnkgPyAnIC8+JyA6ICc+JykpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAvLyBWaXNpdCBhbnkgb3RoZXIgdHlwZSBvZiB0b2tlblxuXHQgICAgICAgIC8vIEFjdHVhbDogYXBwZW5kLlxuXHQgICAgICAgIGFjdHVhbC5wdXNoKHRva2VuUmF3KTtcblx0XG5cdCAgICAgICAgLy8gUHJveHk6IGFwcGVuZCBlbmRUYWdzLiBJZ25vcmUgZXZlcnl0aGluZyBlbHNlLlxuXHQgICAgICAgIHByb3h5LnB1c2godG9rLnR5cGUgPT09ICdlbmRUYWcnID8gdG9rZW5SYXcgOiAnJyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICB0b2tlbnM6IHRva2Vucyxcblx0ICAgICAgcmF3OiByYXcuam9pbignJyksXG5cdCAgICAgIGFjdHVhbDogYWN0dWFsLmpvaW4oJycpLFxuXHQgICAgICBwcm94eTogcHJveHkuam9pbignJylcblx0ICAgIH07XG5cdCAgfTtcblx0XG5cdCAgLyoqXG5cdCAgICogV2FsayB0aGUgY2h1bmtzLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKi9cblx0XG5cdFxuXHQgIFdyaXRlU3RyZWFtLnByb3RvdHlwZS5fd2Fsa0NodW5rID0gZnVuY3Rpb24gX3dhbGtDaHVuaygpIHtcblx0ICAgIHZhciBub2RlID0gdm9pZCAwO1xuXHQgICAgdmFyIHN0YWNrID0gW3RoaXMucHJveHlSb290XTtcblx0XG5cdCAgICAvLyB1c2Ugc2hpZnQvdW5zaGlmdCBzbyB0aGF0IGNoaWxkcmVuIGFyZSB3YWxrZWQgaW4gZG9jdW1lbnQgb3JkZXJcblx0ICAgIHdoaWxlICh1dGlscy5leGlzdHkobm9kZSA9IHN0YWNrLnNoaWZ0KCkpKSB7XG5cdCAgICAgIHZhciBpc0VsZW1lbnQgPSBub2RlLm5vZGVUeXBlID09PSAxO1xuXHQgICAgICB2YXIgaXNQcm94eSA9IGlzRWxlbWVudCAmJiBnZXREYXRhKG5vZGUsICdwcm94eW9mJyk7XG5cdFxuXHQgICAgICAvLyBJZ25vcmUgcHJveGllc1xuXHQgICAgICBpZiAoIWlzUHJveHkpIHtcblx0ICAgICAgICBpZiAoaXNFbGVtZW50KSB7XG5cdCAgICAgICAgICAvLyBOZXcgYWN0dWFsIGVsZW1lbnQ6IHJlZ2lzdGVyIGl0IGFuZCByZW1vdmUgdGhlIHRoZSBpZCBhdHRyLlxuXHQgICAgICAgICAgdGhpcy5hY3R1YWxzW2dldERhdGEobm9kZSwgJ2lkJyldID0gbm9kZTtcblx0ICAgICAgICAgIHNldERhdGEobm9kZSwgJ2lkJyk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvLyBJcyBub2RlJ3MgcGFyZW50IGEgcHJveHk/XG5cdCAgICAgICAgdmFyIHBhcmVudElzUHJveHlPZiA9IG5vZGUucGFyZW50Tm9kZSAmJiBnZXREYXRhKG5vZGUucGFyZW50Tm9kZSwgJ3Byb3h5b2YnKTtcblx0ICAgICAgICBpZiAocGFyZW50SXNQcm94eU9mKSB7XG5cdCAgICAgICAgICAvLyBNb3ZlIG5vZGUgdW5kZXIgYWN0dWFsIHBhcmVudC5cblx0ICAgICAgICAgIHRoaXMuYWN0dWFsc1twYXJlbnRJc1Byb3h5T2ZdLmFwcGVuZENoaWxkKG5vZGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHRcblx0ICAgICAgLy8gcHJlcGVuZCBjaGlsZE5vZGVzIHRvIHN0YWNrXG5cdCAgICAgIHN0YWNrLnVuc2hpZnQuYXBwbHkoc3RhY2ssIHV0aWxzLnRvQXJyYXkobm9kZS5jaGlsZE5vZGVzKSk7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgLyoqXG5cdCAgICogSGFuZGxlcyBTY3JpcHQgdG9rZW5zXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gdG9rIFRoZSB0b2tlblxuXHQgICAqL1xuXHRcblx0XG5cdCAgV3JpdGVTdHJlYW0ucHJvdG90eXBlLl9oYW5kbGVTY3JpcHRUb2tlbiA9IGZ1bmN0aW9uIF9oYW5kbGVTY3JpcHRUb2tlbih0b2spIHtcblx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFxuXHQgICAgdmFyIHJlbWFpbmRlciA9IHRoaXMucGFyc2VyLmNsZWFyKCk7XG5cdFxuXHQgICAgaWYgKHJlbWFpbmRlcikge1xuXHQgICAgICAvLyBXcml0ZSByZW1haW5kZXIgaW1tZWRpYXRlbHkgYmVoaW5kIHRoaXMgc2NyaXB0LlxuXHQgICAgICB0aGlzLndyaXRlUXVldWUudW5zaGlmdChyZW1haW5kZXIpO1xuXHQgICAgfVxuXHRcblx0ICAgIHRvay5zcmMgPSB0b2suYXR0cnMuc3JjIHx8IHRvay5hdHRycy5TUkM7XG5cdFxuXHQgICAgdG9rID0gdGhpcy5vcHRpb25zLmJlZm9yZVdyaXRlVG9rZW4odG9rKTtcblx0ICAgIGlmICghdG9rKSB7XG5cdCAgICAgIC8vIFVzZXIgaGFzIHJlbW92ZWQgdGhpcyB0b2tlblxuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKHRvay5zcmMgJiYgdGhpcy5zY3JpcHRTdGFjay5sZW5ndGgpIHtcblx0ICAgICAgLy8gRGVmZXIgdGhpcyBzY3JpcHQgdW50aWwgc2NyaXB0U3RhY2sgaXMgZW1wdHkuXG5cdCAgICAgIC8vIEFzc3VtcHRpb24gMTogVGhpcyBzY3JpcHQgd2lsbCBub3Qgc3RhcnQgZXhlY3V0aW5nIHVudGlsXG5cdCAgICAgIC8vIHNjcmlwdFN0YWNrIGlzIGVtcHR5LlxuXHQgICAgICB0aGlzLmRlZmVycmVkUmVtb3RlID0gdG9rO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5fb25TY3JpcHRTdGFydCh0b2spO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIFB1dCB0aGUgc2NyaXB0IG5vZGUgaW4gdGhlIERPTS5cblx0ICAgIHRoaXMuX3dyaXRlU2NyaXB0VG9rZW4odG9rLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIF90aGlzLl9vblNjcmlwdERvbmUodG9rKTtcblx0ICAgIH0pO1xuXHQgIH07XG5cdFxuXHQgIC8qKlxuXHQgICAqIEhhbmRsZXMgc3R5bGUgdG9rZW5zXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gdG9rIFRoZSB0b2tlblxuXHQgICAqL1xuXHRcblx0XG5cdCAgV3JpdGVTdHJlYW0ucHJvdG90eXBlLl9oYW5kbGVTdHlsZVRva2VuID0gZnVuY3Rpb24gX2hhbmRsZVN0eWxlVG9rZW4odG9rKSB7XG5cdCAgICB2YXIgcmVtYWluZGVyID0gdGhpcy5wYXJzZXIuY2xlYXIoKTtcblx0XG5cdCAgICBpZiAocmVtYWluZGVyKSB7XG5cdCAgICAgIC8vIFdyaXRlIHJlbWFpbmRlciBpbW1lZGlhdGVseSBiZWhpbmQgdGhpcyBzdHlsZS5cblx0ICAgICAgdGhpcy53cml0ZVF1ZXVlLnVuc2hpZnQocmVtYWluZGVyKTtcblx0ICAgIH1cblx0XG5cdCAgICB0b2sudHlwZSA9IHRvay5hdHRycy50eXBlIHx8IHRvay5hdHRycy5UWVBFIHx8ICd0ZXh0L2Nzcyc7XG5cdFxuXHQgICAgdG9rID0gdGhpcy5vcHRpb25zLmJlZm9yZVdyaXRlVG9rZW4odG9rKTtcblx0XG5cdCAgICBpZiAodG9rKSB7XG5cdCAgICAgIC8vIFB1dCB0aGUgc3R5bGUgbm9kZSBpbiB0aGUgRE9NLlxuXHQgICAgICB0aGlzLl93cml0ZVN0eWxlVG9rZW4odG9rKTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAocmVtYWluZGVyKSB7XG5cdCAgICAgIHRoaXMud3JpdGUoKTtcblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICAvKipcblx0ICAgKiBCdWlsZCBhIHN0eWxlIGFuZCBpbnNlcnQgaXQgaW50byB0aGUgRE9NLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IHRvayBUaGUgdG9rZW5cblx0ICAgKi9cblx0XG5cdFxuXHQgIFdyaXRlU3RyZWFtLnByb3RvdHlwZS5fd3JpdGVTdHlsZVRva2VuID0gZnVuY3Rpb24gX3dyaXRlU3R5bGVUb2tlbih0b2spIHtcblx0ICAgIHZhciBlbCA9IHRoaXMuX2J1aWxkU3R5bGUodG9rKTtcblx0XG5cdCAgICB0aGlzLl9pbnNlcnRDdXJzb3IoZWwsIFBST1hZX1NUWUxFKTtcblx0XG5cdCAgICAvLyBTZXQgY29udGVudFxuXHQgICAgaWYgKHRvay5jb250ZW50KSB7XG5cdCAgICAgIGlmIChlbC5zdHlsZVNoZWV0ICYmICFlbC5zaGVldCkge1xuXHQgICAgICAgIGVsLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHRvay5jb250ZW50O1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuZG9jLmNyZWF0ZVRleHROb2RlKHRvay5jb250ZW50KSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICAvKipcblx0ICAgKiBCdWlsZCBhIHN0eWxlIGVsZW1lbnQgZnJvbSBhbiBhdG9taWMgc3R5bGUgdG9rZW4uXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gdG9rIFRoZSB0b2tlblxuXHQgICAqIEByZXR1cm5zIHtFbGVtZW50fVxuXHQgICAqL1xuXHRcblx0XG5cdCAgV3JpdGVTdHJlYW0ucHJvdG90eXBlLl9idWlsZFN0eWxlID0gZnVuY3Rpb24gX2J1aWxkU3R5bGUodG9rKSB7XG5cdCAgICB2YXIgZWwgPSB0aGlzLmRvYy5jcmVhdGVFbGVtZW50KHRvay50YWdOYW1lKTtcblx0XG5cdCAgICBlbC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCB0b2sudHlwZSk7XG5cdFxuXHQgICAgLy8gU2V0IGF0dHJpYnV0ZXNcblx0ICAgIHV0aWxzLmVhY2hLZXkodG9rLmF0dHJzLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcblx0ICAgICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIHJldHVybiBlbDtcblx0ICB9O1xuXHRcblx0ICAvKipcblx0ICAgKiBBcHBlbmQgYSBzcGFuIHRvIHRoZSBzdHJlYW0uIFRoYXQgc3BhbiB3aWxsIGFjdCBhcyBhIGN1cnNvclxuXHQgICAqIChpLmUuIGluc2VydGlvbiBwb2ludCkgZm9yIHRoZSBlbGVtZW50LlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IGVsIFRoZSBlbGVtZW50XG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IHdoaWNoIFRoZSB0eXBlIG9mIHByb3h5IGVsZW1lbnRcblx0ICAgKi9cblx0XG5cdFxuXHQgIFdyaXRlU3RyZWFtLnByb3RvdHlwZS5faW5zZXJ0Q3Vyc29yID0gZnVuY3Rpb24gX2luc2VydEN1cnNvcihlbCwgd2hpY2gpIHtcblx0ICAgIHRoaXMuX3dyaXRlSW1wbCgnPHNwYW4gaWQ9XCInICsgd2hpY2ggKyAnXCIvPicpO1xuXHRcblx0ICAgIHZhciBjdXJzb3IgPSB0aGlzLmRvYy5nZXRFbGVtZW50QnlJZCh3aGljaCk7XG5cdFxuXHQgICAgaWYgKGN1cnNvcikge1xuXHQgICAgICBjdXJzb3IucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZWwsIGN1cnNvcik7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgLyoqXG5cdCAgICogQ2FsbGVkIHdoZW4gYSBzY3JpcHQgaXMgc3RhcnRlZC5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSB0b2sgVGhlIHRva2VuXG5cdCAgICogQHByaXZhdGVcblx0ICAgKi9cblx0XG5cdFxuXHQgIFdyaXRlU3RyZWFtLnByb3RvdHlwZS5fb25TY3JpcHRTdGFydCA9IGZ1bmN0aW9uIF9vblNjcmlwdFN0YXJ0KHRvaykge1xuXHQgICAgdG9rLm91dGVyV3JpdGVzID0gdGhpcy53cml0ZVF1ZXVlO1xuXHQgICAgdGhpcy53cml0ZVF1ZXVlID0gW107XG5cdCAgICB0aGlzLnNjcmlwdFN0YWNrLnVuc2hpZnQodG9rKTtcblx0ICB9O1xuXHRcblx0ICAvKipcblx0ICAgKiBDYWxsZWQgd2hlbiBhIHNjcmlwdCBpcyBkb25lLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IHRvayBUaGUgdG9rZW5cblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqL1xuXHRcblx0XG5cdCAgV3JpdGVTdHJlYW0ucHJvdG90eXBlLl9vblNjcmlwdERvbmUgPSBmdW5jdGlvbiBfb25TY3JpcHREb25lKHRvaykge1xuXHQgICAgLy8gUG9wIHNjcmlwdCBhbmQgY2hlY2sgbmVzdGluZy5cblx0ICAgIGlmICh0b2sgIT09IHRoaXMuc2NyaXB0U3RhY2tbMF0pIHtcblx0ICAgICAgdGhpcy5vcHRpb25zLmVycm9yKHsgbXNnOiAnQmFkIHNjcmlwdCBuZXN0aW5nIG9yIHNjcmlwdCBmaW5pc2hlZCB0d2ljZScgfSk7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0XG5cdCAgICB0aGlzLnNjcmlwdFN0YWNrLnNoaWZ0KCk7XG5cdFxuXHQgICAgLy8gQXBwZW5kIG91dGVyIHdyaXRlcyB0byBxdWV1ZSBhbmQgcHJvY2VzcyB0aGVtLlxuXHQgICAgdGhpcy53cml0ZS5hcHBseSh0aGlzLCB0b2sub3V0ZXJXcml0ZXMpO1xuXHRcblx0ICAgIC8vIENoZWNrIGZvciBwZW5kaW5nIHJlbW90ZVxuXHRcblx0ICAgIC8vIEFzc3VtcHRpb24gMjogaWYgcmVtb3RlX3NjcmlwdDEgd3JpdGVzIHJlbW90ZV9zY3JpcHQyIHRoZW5cblx0ICAgIC8vIHRoZSB3ZSBub3RpY2UgcmVtb3RlX3NjcmlwdDEgZmluaXNoZXMgYmVmb3JlIHJlbW90ZV9zY3JpcHQyIHN0YXJ0cy5cblx0ICAgIC8vIEkgdGhpbmsgdGhpcyBpcyBlcXVpdmFsZW50IHRvIGFzc3VtcHRpb24gMVxuXHQgICAgaWYgKCF0aGlzLnNjcmlwdFN0YWNrLmxlbmd0aCAmJiB0aGlzLmRlZmVycmVkUmVtb3RlKSB7XG5cdCAgICAgIHRoaXMuX29uU2NyaXB0U3RhcnQodGhpcy5kZWZlcnJlZFJlbW90ZSk7XG5cdCAgICAgIHRoaXMuZGVmZXJyZWRSZW1vdGUgPSBudWxsO1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIC8qKlxuXHQgICAqIEJ1aWxkIGEgc2NyaXB0IGFuZCBpbnNlcnQgaXQgaW50byB0aGUgRE9NLlxuXHQgICAqIERvbmUgaXMgY2FsbGVkIG9uY2Ugc2NyaXB0IGhhcyBleGVjdXRlZC5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSB0b2sgVGhlIHRva2VuXG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZSBUaGUgY2FsbGJhY2sgd2hlbiBjb21wbGV0ZVxuXHQgICAqL1xuXHRcblx0XG5cdCAgV3JpdGVTdHJlYW0ucHJvdG90eXBlLl93cml0ZVNjcmlwdFRva2VuID0gZnVuY3Rpb24gX3dyaXRlU2NyaXB0VG9rZW4odG9rLCBkb25lKSB7XG5cdCAgICB2YXIgZWwgPSB0aGlzLl9idWlsZFNjcmlwdCh0b2spO1xuXHQgICAgdmFyIGFzeW5jUmVsZWFzZSA9IHRoaXMuX3Nob3VsZFJlbGVhc2UoZWwpO1xuXHQgICAgdmFyIGFmdGVyQXN5bmMgPSB0aGlzLm9wdGlvbnMuYWZ0ZXJBc3luYztcblx0XG5cdCAgICBpZiAodG9rLnNyYykge1xuXHQgICAgICAvLyBGaXggZm9yIGF0dHJpYnV0ZSBcIlNSQ1wiIChjYXBpdGFsaXplZCkuIElFIGRvZXMgbm90IHJlY29nbml6ZSBpdC5cblx0ICAgICAgZWwuc3JjID0gdG9rLnNyYztcblx0ICAgICAgdGhpcy5fc2NyaXB0TG9hZEhhbmRsZXIoZWwsICFhc3luY1JlbGVhc2UgPyBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZG9uZSgpO1xuXHQgICAgICAgIGFmdGVyQXN5bmMoKTtcblx0ICAgICAgfSA6IGFmdGVyQXN5bmMpO1xuXHQgICAgfVxuXHRcblx0ICAgIHRyeSB7XG5cdCAgICAgIHRoaXMuX2luc2VydEN1cnNvcihlbCwgUFJPWFlfU0NSSVBUKTtcblx0ICAgICAgaWYgKCFlbC5zcmMgfHwgYXN5bmNSZWxlYXNlKSB7XG5cdCAgICAgICAgZG9uZSgpO1xuXHQgICAgICB9XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgIHRoaXMub3B0aW9ucy5lcnJvcihlKTtcblx0ICAgICAgZG9uZSgpO1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIC8qKlxuXHQgICAqIEJ1aWxkIGEgc2NyaXB0IGVsZW1lbnQgZnJvbSBhbiBhdG9taWMgc2NyaXB0IHRva2VuLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IHRvayBUaGUgdG9rZW5cblx0ICAgKiBAcmV0dXJucyB7RWxlbWVudH1cblx0ICAgKi9cblx0XG5cdFxuXHQgIFdyaXRlU3RyZWFtLnByb3RvdHlwZS5fYnVpbGRTY3JpcHQgPSBmdW5jdGlvbiBfYnVpbGRTY3JpcHQodG9rKSB7XG5cdCAgICB2YXIgZWwgPSB0aGlzLmRvYy5jcmVhdGVFbGVtZW50KHRvay50YWdOYW1lKTtcblx0XG5cdCAgICAvLyBTZXQgYXR0cmlidXRlc1xuXHQgICAgdXRpbHMuZWFjaEtleSh0b2suYXR0cnMsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuXHQgICAgICBlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXHQgICAgfSk7XG5cdFxuXHQgICAgLy8gU2V0IGNvbnRlbnRcblx0ICAgIGlmICh0b2suY29udGVudCkge1xuXHQgICAgICBlbC50ZXh0ID0gdG9rLmNvbnRlbnQ7XG5cdCAgICB9XG5cdFxuXHQgICAgcmV0dXJuIGVsO1xuXHQgIH07XG5cdFxuXHQgIC8qKlxuXHQgICAqIFNldHVwIHRoZSBzY3JpcHQgbG9hZCBoYW5kbGVyIG9uIGFuIGVsZW1lbnQuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gZWwgVGhlIGVsZW1lbnRcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lIFRoZSBjYWxsYmFja1xuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cdFxuXHRcblx0ICBXcml0ZVN0cmVhbS5wcm90b3R5cGUuX3NjcmlwdExvYWRIYW5kbGVyID0gZnVuY3Rpb24gX3NjcmlwdExvYWRIYW5kbGVyKGVsLCBkb25lKSB7XG5cdCAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuXHQgICAgICBlbCA9IGVsLm9ubG9hZCA9IGVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVsLm9uZXJyb3IgPSBudWxsO1xuXHQgICAgfVxuXHRcblx0ICAgIHZhciBlcnJvciA9IHRoaXMub3B0aW9ucy5lcnJvcjtcblx0XG5cdCAgICBmdW5jdGlvbiBzdWNjZXNzKCkge1xuXHQgICAgICBjbGVhbnVwKCk7XG5cdCAgICAgIGlmIChkb25lICE9IG51bGwpIHtcblx0ICAgICAgICBkb25lKCk7XG5cdCAgICAgIH1cblx0ICAgICAgZG9uZSA9IG51bGw7XG5cdCAgICB9XG5cdFxuXHQgICAgZnVuY3Rpb24gZmFpbHVyZShlcnIpIHtcblx0ICAgICAgY2xlYW51cCgpO1xuXHQgICAgICBlcnJvcihlcnIpO1xuXHQgICAgICBpZiAoZG9uZSAhPSBudWxsKSB7XG5cdCAgICAgICAgZG9uZSgpO1xuXHQgICAgICB9XG5cdCAgICAgIGRvbmUgPSBudWxsO1xuXHQgICAgfVxuXHRcblx0ICAgIGZ1bmN0aW9uIHJlYXR0YWNoRXZlbnRMaXN0ZW5lcihlbCwgZXZ0KSB7XG5cdCAgICAgIHZhciBoYW5kbGVyID0gZWxbJ29uJyArIGV2dF07XG5cdCAgICAgIGlmIChoYW5kbGVyICE9IG51bGwpIHtcblx0ICAgICAgICBlbFsnX29uJyArIGV2dF0gPSBoYW5kbGVyO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgcmVhdHRhY2hFdmVudExpc3RlbmVyKGVsLCAnbG9hZCcpO1xuXHQgICAgcmVhdHRhY2hFdmVudExpc3RlbmVyKGVsLCAnZXJyb3InKTtcblx0XG5cdCAgICBfZXh0ZW5kcyhlbCwge1xuXHQgICAgICBvbmxvYWQ6IGZ1bmN0aW9uIG9ubG9hZCgpIHtcblx0ICAgICAgICBpZiAoZWwuX29ubG9hZCkge1xuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgZWwuX29ubG9hZC5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblx0ICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICBmYWlsdXJlKHsgbXNnOiAnb25sb2FkIGhhbmRsZXIgZmFpbGVkICcgKyBlcnIgKyAnIEAgJyArIGVsLnNyYyB9KTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgc3VjY2VzcygpO1xuXHQgICAgICB9LFxuXHQgICAgICBvbmVycm9yOiBmdW5jdGlvbiBvbmVycm9yKCkge1xuXHQgICAgICAgIGlmIChlbC5fb25lcnJvcikge1xuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgZWwuX29uZXJyb3IuYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cdCAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgZmFpbHVyZSh7IG1zZzogJ29uZXJyb3IgaGFuZGxlciBmYWlsZWQgJyArIGVyciArICcgQCAnICsgZWwuc3JjIH0pO1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZhaWx1cmUoeyBtc2c6ICdyZW1vdGUgc2NyaXB0IGZhaWxlZCAnICsgZWwuc3JjIH0pO1xuXHQgICAgICB9LFxuXHQgICAgICBvbnJlYWR5c3RhdGVjaGFuZ2U6IGZ1bmN0aW9uIG9ucmVhZHlzdGF0ZWNoYW5nZSgpIHtcblx0ICAgICAgICBpZiAoL14obG9hZGVkfGNvbXBsZXRlKSQvLnRlc3QoZWwucmVhZHlTdGF0ZSkpIHtcblx0ICAgICAgICAgIHN1Y2Nlc3MoKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cdFxuXHQgIC8qKlxuXHQgICAqIERldGVybWluZXMgd2hldGhlciB0byByZWxlYXNlLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IGVsIFRoZSBlbGVtZW50XG5cdCAgICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAgICogQHByaXZhdGVcblx0ICAgKi9cblx0XG5cdFxuXHQgIFdyaXRlU3RyZWFtLnByb3RvdHlwZS5fc2hvdWxkUmVsZWFzZSA9IGZ1bmN0aW9uIF9zaG91bGRSZWxlYXNlKGVsKSB7XG5cdCAgICB2YXIgaXNTY3JpcHQgPSAvXnNjcmlwdCQvaS50ZXN0KGVsLm5vZGVOYW1lKTtcblx0ICAgIHJldHVybiAhaXNTY3JpcHQgfHwgISEodGhpcy5vcHRpb25zLnJlbGVhc2VBc3luYyAmJiBlbC5zcmMgJiYgZWwuaGFzQXR0cmlidXRlKCdhc3luYycpKTtcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gV3JpdGVTdHJlYW07XG5cdH0oKTtcblx0XG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IFdyaXRlU3RyZWFtO1xuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqXG5cdCAqIEBmaWxlIHByZXNjcmliZVxuXHQgKiBAZGVzY3JpcHRpb24gVGlueSwgZm9yZ2l2aW5nIEhUTUwgcGFyc2VyXG5cdCAqIEB2ZXJzaW9uIHZ1bmRlZmluZWRcblx0ICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2tydXgvcHJlc2NyaWJlL31cblx0ICogQGxpY2Vuc2UgTUlUXG5cdCAqIEBhdXRob3IgRGVyZWsgQnJhbnNcblx0ICogQGNvcHlyaWdodCAyMDE2IEtydXggRGlnaXRhbCwgSW5jXG5cdCAqL1xuXHQoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRcdGlmKHRydWUpXG5cdFx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0XHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdFx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0XHRleHBvcnRzW1wiUHJlc2NyaWJlXCJdID0gZmFjdG9yeSgpO1xuXHRcdGVsc2Vcblx0XHRcdHJvb3RbXCJQcmVzY3JpYmVcIl0gPSBmYWN0b3J5KCk7XG5cdH0pKHRoaXMsIGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuXHQvKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcblx0LyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXHRcblx0LyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuXHQvKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0XG5cdC8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0LyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuXHQvKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblx0XG5cdC8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHQvKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuXHQvKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcblx0LyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuXHQvKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG5cdC8qKioqKiovIFx0XHR9O1xuXHRcblx0LyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHQvKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdFxuXHQvKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHQvKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cdFxuXHQvKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0LyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcblx0LyoqKioqKi8gXHR9XG5cdFxuXHRcblx0LyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuXHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cdFxuXHQvKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG5cdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblx0XG5cdC8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cblx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXHRcblx0LyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcblx0LyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblx0LyoqKioqKi8gfSlcblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKi8gKFtcblx0LyogMCAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0J3VzZSBzdHJpY3QnO1xuXHRcblx0XHR2YXIgX0h0bWxQYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcblx0XHR2YXIgX0h0bWxQYXJzZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSHRtbFBhcnNlcik7XG5cdFxuXHRcdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfSHRtbFBhcnNlcjJbJ2RlZmF1bHQnXTtcblx0XG5cdC8qKiovIH0sXG5cdC8qIDEgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cdFxuXHRcdCd1c2Ugc3RyaWN0Jztcblx0XG5cdFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0XG5cdFx0dmFyIF9zdXBwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdFxuXHRcdHZhciBzdXBwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9zdXBwb3J0cyk7XG5cdFxuXHRcdHZhciBfc3RyZWFtUmVhZGVycyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdFxuXHRcdHZhciBzdHJlYW1SZWFkZXJzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3N0cmVhbVJlYWRlcnMpO1xuXHRcblx0XHR2YXIgX2ZpeGVkUmVhZFRva2VuRmFjdG9yeSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdFxuXHRcdHZhciBfZml4ZWRSZWFkVG9rZW5GYWN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZpeGVkUmVhZFRva2VuRmFjdG9yeSk7XG5cdFxuXHRcdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHRcblx0XHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cdFxuXHRcdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cdFxuXHRcdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cdFxuXHRcdC8qKlxuXHRcdCAqIERldGVjdGlvbiByZWd1bGFyIGV4cHJlc3Npb25zLlxuXHRcdCAqXG5cdFx0ICogT3JkZXIgb2YgZGV0ZWN0aW9uIG1hdHRlcnM6IGRldGVjdGlvbiBvZiBvbmUgY2FuIG9ubHlcblx0XHQgKiBzdWNjZWVkIGlmIGRldGVjdGlvbiBvZiBwcmV2aW91cyBkaWRuJ3Rcblx0XG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR2YXIgZGV0ZWN0ID0ge1xuXHRcdCAgY29tbWVudDogL148IS0tLyxcblx0XHQgIGVuZFRhZzogL148XFwvLyxcblx0XHQgIGF0b21pY1RhZzogL148XFxzKihzY3JpcHR8c3R5bGV8bm9zY3JpcHR8aWZyYW1lfHRleHRhcmVhKVtcXHNcXC8+XS9pLFxuXHRcdCAgc3RhcnRUYWc6IC9ePC8sXG5cdFx0ICBjaGFyczogL15bXjxdL1xuXHRcdH07XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEh0bWxQYXJzZXIgcHJvdmlkZXMgdGhlIGNhcGFiaWxpdHkgdG8gcGFyc2UgSFRNTCBhbmQgcmV0dXJuIHRva2Vuc1xuXHRcdCAqIHJlcHJlc2VudGluZyB0aGUgdGFncyBhbmQgY29udGVudC5cblx0XHQgKi9cblx0XG5cdFx0dmFyIEh0bWxQYXJzZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAvKipcblx0XHQgICAqIENvbnN0cnVjdG9yLlxuXHRcdCAgICpcblx0XHQgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJlYW0gVGhlIGluaXRpYWwgcGFyc2Ugc3RyZWFtIGNvbnRlbnRzLlxuXHRcdCAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnNcblx0XHQgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5hdXRvRml4IFNldCB0byB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgZml4IGVycm9yc1xuXHRcdCAgICovXG5cdFx0ICBmdW5jdGlvbiBIdG1sUGFyc2VyKCkge1xuXHRcdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcblx0XHQgICAgdmFyIHN0cmVhbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG5cdFx0ICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblx0XG5cdFx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIdG1sUGFyc2VyKTtcblx0XG5cdFx0ICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuXHRcblx0XHQgICAgdmFyIGZpeCA9IGZhbHNlO1xuXHRcdCAgICB2YXIgZml4ZWRUb2tlbk9wdGlvbnMgPSB7fTtcblx0XG5cdFx0ICAgIGZvciAodmFyIGtleSBpbiBzdXBwb3J0cykge1xuXHRcdCAgICAgIGlmIChzdXBwb3J0cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0ICAgICAgICBpZiAob3B0aW9ucy5hdXRvRml4KSB7XG5cdFx0ICAgICAgICAgIGZpeGVkVG9rZW5PcHRpb25zW2tleSArICdGaXgnXSA9IHRydWU7IC8vICFzdXBwb3J0c1trZXldO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZml4ID0gZml4IHx8IGZpeGVkVG9rZW5PcHRpb25zW2tleSArICdGaXgnXTtcblx0XHQgICAgICB9XG5cdFx0ICAgIH1cblx0XG5cdFx0ICAgIGlmIChmaXgpIHtcblx0XHQgICAgICB0aGlzLl9yZWFkVG9rZW4gPSAoMCwgX2ZpeGVkUmVhZFRva2VuRmFjdG9yeTJbJ2RlZmF1bHQnXSkodGhpcywgZml4ZWRUb2tlbk9wdGlvbnMsIGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIHJldHVybiBfdGhpcy5fcmVhZFRva2VuSW1wbCgpO1xuXHRcdCAgICAgIH0pO1xuXHRcdCAgICAgIHRoaXMuX3BlZWtUb2tlbiA9ICgwLCBfZml4ZWRSZWFkVG9rZW5GYWN0b3J5MlsnZGVmYXVsdCddKSh0aGlzLCBmaXhlZFRva2VuT3B0aW9ucywgZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIF90aGlzLl9wZWVrVG9rZW5JbXBsKCk7XG5cdFx0ICAgICAgfSk7XG5cdFx0ICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgdGhpcy5fcmVhZFRva2VuID0gdGhpcy5fcmVhZFRva2VuSW1wbDtcblx0XHQgICAgICB0aGlzLl9wZWVrVG9rZW4gPSB0aGlzLl9wZWVrVG9rZW5JbXBsO1xuXHRcdCAgICB9XG5cdFx0ICB9XG5cdFxuXHRcdCAgLyoqXG5cdFx0ICAgKiBBcHBlbmRzIHRoZSBnaXZlbiBzdHJpbmcgdG8gdGhlIHBhcnNlIHN0cmVhbS5cblx0XHQgICAqXG5cdFx0ICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gYXBwZW5kXG5cdFx0ICAgKi9cblx0XG5cdFxuXHRcdCAgSHRtbFBhcnNlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKHN0cikge1xuXHRcdCAgICB0aGlzLnN0cmVhbSArPSBzdHI7XG5cdFx0ICB9O1xuXHRcblx0XHQgIC8qKlxuXHRcdCAgICogUHJlcGVuZHMgdGhlIGdpdmVuIHN0cmluZyB0byB0aGUgcGFyc2Ugc3RyZWFtLlxuXHRcdCAgICpcblx0XHQgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBwcmVwZW5kXG5cdFx0ICAgKi9cblx0XG5cdFxuXHRcdCAgSHRtbFBhcnNlci5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQoc3RyKSB7XG5cdFx0ICAgIHRoaXMuc3RyZWFtID0gc3RyICsgdGhpcy5zdHJlYW07XG5cdFx0ICB9O1xuXHRcblx0XHQgIC8qKlxuXHRcdCAgICogVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSB0b2tlbiByZWFkaW5nLlxuXHRcdCAgICpcblx0XHQgICAqIEBwcml2YXRlXG5cdFx0ICAgKiBAcmV0dXJucyB7P1Rva2VufVxuXHRcdCAgICovXG5cdFxuXHRcblx0XHQgIEh0bWxQYXJzZXIucHJvdG90eXBlLl9yZWFkVG9rZW5JbXBsID0gZnVuY3Rpb24gX3JlYWRUb2tlbkltcGwoKSB7XG5cdFx0ICAgIHZhciB0b2tlbiA9IHRoaXMuX3BlZWtUb2tlbkltcGwoKTtcblx0XHQgICAgaWYgKHRva2VuKSB7XG5cdFx0ICAgICAgdGhpcy5zdHJlYW0gPSB0aGlzLnN0cmVhbS5zbGljZSh0b2tlbi5sZW5ndGgpO1xuXHRcdCAgICAgIHJldHVybiB0b2tlbjtcblx0XHQgICAgfVxuXHRcdCAgfTtcblx0XG5cdFx0ICAvKipcblx0XHQgICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0b2tlbiBwZWVraW5nLlxuXHRcdCAgICpcblx0XHQgICAqIEByZXR1cm5zIHs/VG9rZW59XG5cdFx0ICAgKi9cblx0XG5cdFxuXHRcdCAgSHRtbFBhcnNlci5wcm90b3R5cGUuX3BlZWtUb2tlbkltcGwgPSBmdW5jdGlvbiBfcGVla1Rva2VuSW1wbCgpIHtcblx0XHQgICAgZm9yICh2YXIgdHlwZSBpbiBkZXRlY3QpIHtcblx0XHQgICAgICBpZiAoZGV0ZWN0Lmhhc093blByb3BlcnR5KHR5cGUpKSB7XG5cdFx0ICAgICAgICBpZiAoZGV0ZWN0W3R5cGVdLnRlc3QodGhpcy5zdHJlYW0pKSB7XG5cdFx0ICAgICAgICAgIHZhciB0b2tlbiA9IHN0cmVhbVJlYWRlcnNbdHlwZV0odGhpcy5zdHJlYW0pO1xuXHRcblx0XHQgICAgICAgICAgaWYgKHRva2VuKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdzdGFydFRhZycgJiYgL3NjcmlwdHxzdHlsZS9pLnRlc3QodG9rZW4udGFnTmFtZSkpIHtcblx0XHQgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHRcdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICB0b2tlbi50ZXh0ID0gdGhpcy5zdHJlYW0uc3Vic3RyKDAsIHRva2VuLmxlbmd0aCk7XG5cdFx0ICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICB9O1xuXHRcblx0XHQgIC8qKlxuXHRcdCAgICogVGhlIHB1YmxpYyB0b2tlbiBwZWVraW5nIGludGVyZmFjZS4gIERlbGVnYXRlcyB0byB0aGUgYmFzaWMgdG9rZW4gcGVla2luZ1xuXHRcdCAgICogb3IgYSB2ZXJzaW9uIHRoYXQgcGVyZm9ybXMgZml4dXBzIGRlcGVuZGluZyBvbiB0aGUgYGF1dG9GaXhgIHNldHRpbmcgaW5cblx0XHQgICAqIG9wdGlvbnMuXG5cdFx0ICAgKlxuXHRcdCAgICogQHJldHVybnMge29iamVjdH1cblx0XHQgICAqL1xuXHRcblx0XG5cdFx0ICBIdG1sUGFyc2VyLnByb3RvdHlwZS5wZWVrVG9rZW4gPSBmdW5jdGlvbiBwZWVrVG9rZW4oKSB7XG5cdFx0ICAgIHJldHVybiB0aGlzLl9wZWVrVG9rZW4oKTtcblx0XHQgIH07XG5cdFxuXHRcdCAgLyoqXG5cdFx0ICAgKiBUaGUgcHVibGljIHRva2VuIHJlYWRpbmcgaW50ZXJmYWNlLiAgRGVsZWdhdGVzIHRvIHRoZSBiYXNpYyB0b2tlbiByZWFkaW5nXG5cdFx0ICAgKiBvciBhIHZlcnNpb24gdGhhdCBwZXJmb3JtcyBmaXh1cHMgZGVwZW5kaW5nIG9uIHRoZSBgYXV0b0ZpeGAgc2V0dGluZyBpblxuXHRcdCAgICogb3B0aW9ucy5cblx0XHQgICAqXG5cdFx0ICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuXHRcdCAgICovXG5cdFxuXHRcblx0XHQgIEh0bWxQYXJzZXIucHJvdG90eXBlLnJlYWRUb2tlbiA9IGZ1bmN0aW9uIHJlYWRUb2tlbigpIHtcblx0XHQgICAgcmV0dXJuIHRoaXMuX3JlYWRUb2tlbigpO1xuXHRcdCAgfTtcblx0XG5cdFx0ICAvKipcblx0XHQgICAqIFJlYWQgdG9rZW5zIGFuZCBoYW5kIHRvIHRoZSBnaXZlbiBoYW5kbGVycy5cblx0XHQgICAqXG5cdFx0ICAgKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlcnMgVGhlIGhhbmRsZXJzIHRvIHVzZSBmb3IgdGhlIGRpZmZlcmVudCB0b2tlbnMuXG5cdFx0ICAgKi9cblx0XG5cdFxuXHRcdCAgSHRtbFBhcnNlci5wcm90b3R5cGUucmVhZFRva2VucyA9IGZ1bmN0aW9uIHJlYWRUb2tlbnMoaGFuZGxlcnMpIHtcblx0XHQgICAgdmFyIHRvayA9IHZvaWQgMDtcblx0XHQgICAgd2hpbGUgKHRvayA9IHRoaXMucmVhZFRva2VuKCkpIHtcblx0XHQgICAgICAvLyBjb250aW51ZSB1bnRpbCB3ZSBnZXQgYW4gZXhwbGljaXQgXCJmYWxzZVwiIHJldHVyblxuXHRcdCAgICAgIGlmIChoYW5kbGVyc1t0b2sudHlwZV0gJiYgaGFuZGxlcnNbdG9rLnR5cGVdKHRvaykgPT09IGZhbHNlKSB7XG5cdFx0ICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICB9O1xuXHRcblx0XHQgIC8qKlxuXHRcdCAgICogQ2xlYXJzIHRoZSBwYXJzZSBzdHJlYW0uXG5cdFx0ICAgKlxuXHRcdCAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbnRlbnRzIG9mIHRoZSBwYXJzZSBzdHJlYW0gYmVmb3JlIGNsZWFyaW5nLlxuXHRcdCAgICovXG5cdFxuXHRcblx0XHQgIEh0bWxQYXJzZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG5cdFx0ICAgIHZhciByZXN0ID0gdGhpcy5zdHJlYW07XG5cdFx0ICAgIHRoaXMuc3RyZWFtID0gJyc7XG5cdFx0ICAgIHJldHVybiByZXN0O1xuXHRcdCAgfTtcblx0XG5cdFx0ICAvKipcblx0XHQgICAqIFJldHVybnMgdGhlIHJlc3Qgb2YgdGhlIHBhcnNlIHN0cmVhbS5cblx0XHQgICAqXG5cdFx0ICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29udGVudHMgb2YgdGhlIHBhcnNlIHN0cmVhbS5cblx0XHQgICAqL1xuXHRcblx0XG5cdFx0ICBIdG1sUGFyc2VyLnByb3RvdHlwZS5yZXN0ID0gZnVuY3Rpb24gcmVzdCgpIHtcblx0XHQgICAgcmV0dXJuIHRoaXMuc3RyZWFtO1xuXHRcdCAgfTtcblx0XG5cdFx0ICByZXR1cm4gSHRtbFBhcnNlcjtcblx0XHR9KCk7XG5cdFxuXHRcdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IEh0bWxQYXJzZXI7XG5cdFxuXHRcblx0XHRIdG1sUGFyc2VyLnRva2VuVG9TdHJpbmcgPSBmdW5jdGlvbiAodG9rKSB7XG5cdFx0ICByZXR1cm4gdG9rLnRvU3RyaW5nKCk7XG5cdFx0fTtcblx0XG5cdFx0SHRtbFBhcnNlci5lc2NhcGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJzKSB7XG5cdFx0ICB2YXIgZXNjYXBlZEF0dHJzID0ge307XG5cdFxuXHRcdCAgZm9yICh2YXIgbmFtZSBpbiBhdHRycykge1xuXHRcdCAgICBpZiAoYXR0cnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHQgICAgICBlc2NhcGVkQXR0cnNbbmFtZV0gPSAoMCwgX3V0aWxzLmVzY2FwZVF1b3RlcykoYXR0cnNbbmFtZV0sIG51bGwpO1xuXHRcdCAgICB9XG5cdFx0ICB9XG5cdFxuXHRcdCAgcmV0dXJuIGVzY2FwZWRBdHRycztcblx0XHR9O1xuXHRcblx0XHRIdG1sUGFyc2VyLnN1cHBvcnRzID0gc3VwcG9ydHM7XG5cdFxuXHRcdGZvciAodmFyIGtleSBpbiBzdXBwb3J0cykge1xuXHRcdCAgaWYgKHN1cHBvcnRzLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHQgICAgSHRtbFBhcnNlci5icm93c2VySGFzRmxhdyA9IEh0bWxQYXJzZXIuYnJvd3Nlckhhc0ZsYXcgfHwgIXN1cHBvcnRzW2tleV0gJiYga2V5O1xuXHRcdCAgfVxuXHRcdH1cblx0XG5cdC8qKiovIH0sXG5cdC8qIDIgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFxuXHRcdCd1c2Ugc3RyaWN0Jztcblx0XG5cdFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0XHR2YXIgdGFnU291cCA9IGZhbHNlO1xuXHRcdHZhciBzZWxmQ2xvc2UgPSBmYWxzZTtcblx0XG5cdFx0dmFyIHdvcmsgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFxuXHRcdHRyeSB7XG5cdFx0ICB2YXIgaHRtbCA9ICc8UD48ST48L1A+PC9JPic7XG5cdFx0ICB3b3JrLmlubmVySFRNTCA9IGh0bWw7XG5cdFx0ICBleHBvcnRzLnRhZ1NvdXAgPSB0YWdTb3VwID0gd29yay5pbm5lckhUTUwgIT09IGh0bWw7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdCAgZXhwb3J0cy50YWdTb3VwID0gdGFnU291cCA9IGZhbHNlO1xuXHRcdH1cblx0XG5cdFx0dHJ5IHtcblx0XHQgIHdvcmsuaW5uZXJIVE1MID0gJzxQPjxpPjxQPjwvUD48L2k+PC9QPic7XG5cdFx0ICBleHBvcnRzLnNlbGZDbG9zZSA9IHNlbGZDbG9zZSA9IHdvcmsuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdCAgZXhwb3J0cy5zZWxmQ2xvc2UgPSBzZWxmQ2xvc2UgPSBmYWxzZTtcblx0XHR9XG5cdFxuXHRcdHdvcmsgPSBudWxsO1xuXHRcblx0XHRleHBvcnRzLnRhZ1NvdXAgPSB0YWdTb3VwO1xuXHRcdGV4cG9ydHMuc2VsZkNsb3NlID0gc2VsZkNsb3NlO1xuXHRcblx0LyoqKi8gfSxcblx0LyogMyAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0J3VzZSBzdHJpY3QnO1xuXHRcblx0XHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRcblx0XHR2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cdFxuXHRcdGV4cG9ydHMuY29tbWVudCA9IGNvbW1lbnQ7XG5cdFx0ZXhwb3J0cy5jaGFycyA9IGNoYXJzO1xuXHRcdGV4cG9ydHMuc3RhcnRUYWcgPSBzdGFydFRhZztcblx0XHRleHBvcnRzLmF0b21pY1RhZyA9IGF0b21pY1RhZztcblx0XHRleHBvcnRzLmVuZFRhZyA9IGVuZFRhZztcblx0XG5cdFx0dmFyIF90b2tlbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcblx0XHQvKipcblx0XHQgKiBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dmFyIFJFR0VYRVMgPSB7XG5cdFx0ICBzdGFydFRhZzogL148KFtcXC1BLVphLXowLTlfXSspKCg/OlxccytbXFx3XFwtXSsoPzpcXHMqPT9cXHMqKD86KD86XCJbXlwiXSpcIil8KD86J1teJ10qJyl8W14+XFxzXSspKT8pKilcXHMqKFxcLz8pPi8sXG5cdFx0ICBlbmRUYWc6IC9ePFxcLyhbXFwtQS1aYS16MC05X10rKVtePl0qPi8sXG5cdFx0ICBhdHRyOiAvKD86KFtcXC1BLVphLXowLTlfXSspXFxzKj1cXHMqKD86KD86XCIoKD86XFxcXC58W15cIl0pKilcIil8KD86JygoPzpcXFxcLnxbXiddKSopJyl8KFtePlxcc10rKSkpfCg/OihbXFwtQS1aYS16MC05X10rKShcXHN8JCkrKS9nLFxuXHRcdCAgZmlsbEF0dHI6IC9eKGNoZWNrZWR8Y29tcGFjdHxkZWNsYXJlfGRlZmVyfGRpc2FibGVkfGlzbWFwfG11bHRpcGxlfG5vaHJlZnxub3Jlc2l6ZXxub3NoYWRlfG5vd3JhcHxyZWFkb25seXxzZWxlY3RlZCkkL2lcblx0XHR9O1xuXHRcblx0XHQvKipcblx0XHQgKiBSZWFkcyBhIGNvbW1lbnQgdG9rZW5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJlYW0gVGhlIGlucHV0IHN0cmVhbVxuXHRcdCAqIEByZXR1cm5zIHtDb21tZW50VG9rZW59XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gY29tbWVudChzdHJlYW0pIHtcblx0XHQgIHZhciBpbmRleCA9IHN0cmVhbS5pbmRleE9mKCctLT4nKTtcblx0XHQgIGlmIChpbmRleCA+PSAwKSB7XG5cdFx0ICAgIHJldHVybiBuZXcgX3Rva2Vucy5Db21tZW50VG9rZW4oc3RyZWFtLnN1YnN0cig0LCBpbmRleCAtIDEpLCBpbmRleCArIDMpO1xuXHRcdCAgfVxuXHRcdH1cblx0XG5cdFx0LyoqXG5cdFx0ICogUmVhZHMgbm9uLXRhZyBjaGFyYWN0ZXJzLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmVhbSBUaGUgaW5wdXQgc3RyZWFtXG5cdFx0ICogQHJldHVybnMge0NoYXJzVG9rZW59XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gY2hhcnMoc3RyZWFtKSB7XG5cdFx0ICB2YXIgaW5kZXggPSBzdHJlYW0uaW5kZXhPZignPCcpO1xuXHRcdCAgcmV0dXJuIG5ldyBfdG9rZW5zLkNoYXJzVG9rZW4oaW5kZXggPj0gMCA/IGluZGV4IDogc3RyZWFtLmxlbmd0aCk7XG5cdFx0fVxuXHRcblx0XHQvKipcblx0XHQgKiBSZWFkcyBzdGFydCB0YWcgdG9rZW4uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyZWFtIFRoZSBpbnB1dCBzdHJlYW1cblx0XHQgKiBAcmV0dXJucyB7U3RhcnRUYWdUb2tlbn1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBzdGFydFRhZyhzdHJlYW0pIHtcblx0XHQgIHZhciBlbmRUYWdJbmRleCA9IHN0cmVhbS5pbmRleE9mKCc+Jyk7XG5cdFx0ICBpZiAoZW5kVGFnSW5kZXggIT09IC0xKSB7XG5cdFx0ICAgIHZhciBtYXRjaCA9IHN0cmVhbS5tYXRjaChSRUdFWEVTLnN0YXJ0VGFnKTtcblx0XHQgICAgaWYgKG1hdGNoKSB7XG5cdFx0ICAgICAgdmFyIF9yZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB2YXIgYXR0cnMgPSB7fTtcblx0XHQgICAgICAgIHZhciBib29sZWFuQXR0cnMgPSB7fTtcblx0XHQgICAgICAgIHZhciByZXN0ID0gbWF0Y2hbMl07XG5cdFxuXHRcdCAgICAgICAgbWF0Y2hbMl0ucmVwbGFjZShSRUdFWEVTLmF0dHIsIGZ1bmN0aW9uIChtYXRjaCwgbmFtZSkge1xuXHRcdCAgICAgICAgICBpZiAoIShhcmd1bWVudHNbMl0gfHwgYXJndW1lbnRzWzNdIHx8IGFyZ3VtZW50c1s0XSB8fCBhcmd1bWVudHNbNV0pKSB7XG5cdFx0ICAgICAgICAgICAgYXR0cnNbbmFtZV0gPSAnJztcblx0XHQgICAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHNbNV0pIHtcblx0XHQgICAgICAgICAgICBhdHRyc1thcmd1bWVudHNbNV1dID0gJyc7XG5cdFx0ICAgICAgICAgICAgYm9vbGVhbkF0dHJzW2FyZ3VtZW50c1s1XV0gPSB0cnVlO1xuXHRcdCAgICAgICAgICB9IGVsc2Uge1xuXHRcdCAgICAgICAgICAgIGF0dHJzW25hbWVdID0gYXJndW1lbnRzWzJdIHx8IGFyZ3VtZW50c1szXSB8fCBhcmd1bWVudHNbNF0gfHwgUkVHRVhFUy5maWxsQXR0ci50ZXN0KG5hbWUpICYmIG5hbWUgfHwgJyc7XG5cdFx0ICAgICAgICAgIH1cblx0XG5cdFx0ICAgICAgICAgIHJlc3QgPSByZXN0LnJlcGxhY2UobWF0Y2gsICcnKTtcblx0XHQgICAgICAgIH0pO1xuXHRcblx0XHQgICAgICAgIHJldHVybiB7XG5cdFx0ICAgICAgICAgIHY6IG5ldyBfdG9rZW5zLlN0YXJ0VGFnVG9rZW4obWF0Y2hbMV0sIG1hdGNoWzBdLmxlbmd0aCwgYXR0cnMsIGJvb2xlYW5BdHRycywgISFtYXRjaFszXSwgcmVzdC5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpKVxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgICB9KCk7XG5cdFxuXHRcdCAgICAgIGlmICgodHlwZW9mIF9yZXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKF9yZXQpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcblx0XHQgICAgfVxuXHRcdCAgfVxuXHRcdH1cblx0XG5cdFx0LyoqXG5cdFx0ICogUmVhZHMgYXRvbWljIHRhZyB0b2tlbi5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJlYW0gVGhlIGlucHV0IHN0cmVhbVxuXHRcdCAqIEByZXR1cm5zIHtBdG9taWNUYWdUb2tlbn1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBhdG9taWNUYWcoc3RyZWFtKSB7XG5cdFx0ICB2YXIgc3RhcnQgPSBzdGFydFRhZyhzdHJlYW0pO1xuXHRcdCAgaWYgKHN0YXJ0KSB7XG5cdFx0ICAgIHZhciByZXN0ID0gc3RyZWFtLnNsaWNlKHN0YXJ0Lmxlbmd0aCk7XG5cdFx0ICAgIC8vIGZvciBvcHRpbWl6YXRpb24sIHdlIGNoZWNrIGZpcnN0IGp1c3QgZm9yIHRoZSBlbmQgdGFnXG5cdFx0ICAgIGlmIChyZXN0Lm1hdGNoKG5ldyBSZWdFeHAoJzxcXC9cXFxccyonICsgc3RhcnQudGFnTmFtZSArICdcXFxccyo+JywgJ2knKSkpIHtcblx0XHQgICAgICAvLyBjYXB0dXJpbmcgdGhlIGNvbnRlbnQgaXMgaW5lZmZpY2llbnQsIHNvIHdlIGRvIGl0IGluc2lkZSB0aGUgaWZcblx0XHQgICAgICB2YXIgbWF0Y2ggPSByZXN0Lm1hdGNoKG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPyk8XFwvXFxcXHMqJyArIHN0YXJ0LnRhZ05hbWUgKyAnXFxcXHMqPicsICdpJykpO1xuXHRcdCAgICAgIGlmIChtYXRjaCkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBfdG9rZW5zLkF0b21pY1RhZ1Rva2VuKHN0YXJ0LnRhZ05hbWUsIG1hdGNoWzBdLmxlbmd0aCArIHN0YXJ0Lmxlbmd0aCwgc3RhcnQuYXR0cnMsIHN0YXJ0LmJvb2xlYW5BdHRycywgbWF0Y2hbMV0pO1xuXHRcdCAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgfVxuXHRcdH1cblx0XG5cdFx0LyoqXG5cdFx0ICogUmVhZHMgYW4gZW5kIHRhZyB0b2tlbi5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJlYW0gVGhlIGlucHV0IHN0cmVhbVxuXHRcdCAqIEByZXR1cm5zIHtFbmRUYWdUb2tlbn1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBlbmRUYWcoc3RyZWFtKSB7XG5cdFx0ICB2YXIgbWF0Y2ggPSBzdHJlYW0ubWF0Y2goUkVHRVhFUy5lbmRUYWcpO1xuXHRcdCAgaWYgKG1hdGNoKSB7XG5cdFx0ICAgIHJldHVybiBuZXcgX3Rva2Vucy5FbmRUYWdUb2tlbihtYXRjaFsxXSwgbWF0Y2hbMF0ubGVuZ3RoKTtcblx0XHQgIH1cblx0XHR9XG5cdFxuXHQvKioqLyB9LFxuXHQvKiA0ICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHQndXNlIHN0cmljdCc7XG5cdFxuXHRcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdFx0ZXhwb3J0cy5FbmRUYWdUb2tlbiA9IGV4cG9ydHMuQXRvbWljVGFnVG9rZW4gPSBleHBvcnRzLlN0YXJ0VGFnVG9rZW4gPSBleHBvcnRzLlRhZ1Rva2VuID0gZXhwb3J0cy5DaGFyc1Rva2VuID0gZXhwb3J0cy5Db21tZW50VG9rZW4gPSBleHBvcnRzLlRva2VuID0gdW5kZWZpbmVkO1xuXHRcblx0XHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0XG5cdFx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdFx0LyoqXG5cdFx0ICogVG9rZW4gaXMgYSBiYXNlIGNsYXNzIGZvciBhbGwgdG9rZW4gdHlwZXMgcGFyc2VkLiAgTm90ZSB3ZSBkb24ndCBhY3R1YWxseVxuXHRcdCAqIHVzZSBpbnRoZXJpdGFuY2UgZHVlIHRvIElFOCdzIG5vbi1leGlzdGVudCBFUzUgc3VwcG9ydC5cblx0XHQgKi9cblx0XHR2YXIgVG9rZW4gPVxuXHRcdC8qKlxuXHRcdCAqIENvbnN0cnVjdG9yLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgdGhlIFRva2VuLlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgVG9rZW4gdGV4dC5cblx0XHQgKi9cblx0XHRleHBvcnRzLlRva2VuID0gZnVuY3Rpb24gVG9rZW4odHlwZSwgbGVuZ3RoKSB7XG5cdFx0ICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9rZW4pO1xuXHRcblx0XHQgIHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0ICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcblx0XHQgIHRoaXMudGV4dCA9ICcnO1xuXHRcdH07XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENvbW1lbnRUb2tlbiByZXByZXNlbnRzIGNvbW1lbnQgdGFncy5cblx0XHQgKi9cblx0XG5cdFxuXHRcdHZhciBDb21tZW50VG9rZW4gPSBleHBvcnRzLkNvbW1lbnRUb2tlbiA9IGZ1bmN0aW9uICgpIHtcblx0XHQgIC8qKlxuXHRcdCAgICogQ29uc3RydWN0b3IuXG5cdFx0ICAgKlxuXHRcdCAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIGNvbW1lbnRcblx0XHQgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgVG9rZW4gdGV4dC5cblx0XHQgICAqL1xuXHRcdCAgZnVuY3Rpb24gQ29tbWVudFRva2VuKGNvbnRlbnQsIGxlbmd0aCkge1xuXHRcdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tbWVudFRva2VuKTtcblx0XG5cdFx0ICAgIHRoaXMudHlwZSA9ICdjb21tZW50Jztcblx0XHQgICAgdGhpcy5sZW5ndGggPSBsZW5ndGggfHwgKGNvbnRlbnQgPyBjb250ZW50Lmxlbmd0aCA6IDApO1xuXHRcdCAgICB0aGlzLnRleHQgPSAnJztcblx0XHQgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcblx0XHQgIH1cblx0XG5cdFx0ICBDb21tZW50VG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0ICAgIHJldHVybiAnPCEtLScgKyB0aGlzLmNvbnRlbnQ7XG5cdFx0ICB9O1xuXHRcblx0XHQgIHJldHVybiBDb21tZW50VG9rZW47XG5cdFx0fSgpO1xuXHRcblx0XHQvKipcblx0XHQgKiBDaGFyc1Rva2VuIHJlcHJlc2VudHMgbm9uLXRhZyBjaGFyYWN0ZXJzLlxuXHRcdCAqL1xuXHRcblx0XG5cdFx0dmFyIENoYXJzVG9rZW4gPSBleHBvcnRzLkNoYXJzVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAvKipcblx0XHQgICAqIENvbnN0cnVjdG9yLlxuXHRcdCAgICpcblx0XHQgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgVG9rZW4gdGV4dC5cblx0XHQgICAqL1xuXHRcdCAgZnVuY3Rpb24gQ2hhcnNUb2tlbihsZW5ndGgpIHtcblx0XHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoYXJzVG9rZW4pO1xuXHRcblx0XHQgICAgdGhpcy50eXBlID0gJ2NoYXJzJztcblx0XHQgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG5cdFx0ICAgIHRoaXMudGV4dCA9ICcnO1xuXHRcdCAgfVxuXHRcblx0XHQgIENoYXJzVG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0ICAgIHJldHVybiB0aGlzLnRleHQ7XG5cdFx0ICB9O1xuXHRcblx0XHQgIHJldHVybiBDaGFyc1Rva2VuO1xuXHRcdH0oKTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGFnVG9rZW4gaXMgYSBiYXNlIGNsYXNzIGZvciBhbGwgdGFnLWJhc2VkIFRva2Vucy5cblx0XHQgKi9cblx0XG5cdFxuXHRcdHZhciBUYWdUb2tlbiA9IGV4cG9ydHMuVGFnVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAvKipcblx0XHQgICAqIENvbnN0cnVjdG9yLlxuXHRcdCAgICpcblx0XHQgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSB0b2tlbi5cblx0XHQgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIFRoZSB0YWcgbmFtZS5cblx0XHQgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgVG9rZW4gdGV4dC5cblx0XHQgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRycyBUaGUgZGljdGlvbmFyeSBvZiBhdHRyaWJ1dGVzIGFuZCB2YWx1ZXNcblx0XHQgICAqIEBwYXJhbSB7T2JqZWN0fSBib29sZWFuQXR0cnMgSWYgYW4gZW50cnkgaGFzICd0cnVlJyB0aGVuIHRoZSBhdHRyaWJ1dGVcblx0XHQgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgYSBib29sZWFuIGF0dHJpYnV0ZVxuXHRcdCAgICovXG5cdFx0ICBmdW5jdGlvbiBUYWdUb2tlbih0eXBlLCB0YWdOYW1lLCBsZW5ndGgsIGF0dHJzLCBib29sZWFuQXR0cnMpIHtcblx0XHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRhZ1Rva2VuKTtcblx0XG5cdFx0ICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0ICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuXHRcdCAgICB0aGlzLnRleHQgPSAnJztcblx0XHQgICAgdGhpcy50YWdOYW1lID0gdGFnTmFtZTtcblx0XHQgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuXHRcdCAgICB0aGlzLmJvb2xlYW5BdHRycyA9IGJvb2xlYW5BdHRycztcblx0XHQgICAgdGhpcy51bmFyeSA9IGZhbHNlO1xuXHRcdCAgICB0aGlzLmh0bWw1VW5hcnkgPSBmYWxzZTtcblx0XHQgIH1cblx0XG5cdFx0ICAvKipcblx0XHQgICAqIEZvcm1hdHMgdGhlIGdpdmVuIHRva2VuIHRhZy5cblx0XHQgICAqXG5cdFx0ICAgKiBAcGFyYW0ge1RhZ1Rva2VufSB0b2sgVGhlIFRhZ1Rva2VuIHRvIGZvcm1hdC5cblx0XHQgICAqIEBwYXJhbSB7P3N0cmluZ30gW2NvbnRlbnQ9bnVsbF0gVGhlIGNvbnRlbnQgb2YgdGhlIHRva2VuLlxuXHRcdCAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB0YWcuXG5cdFx0ICAgKi9cblx0XG5cdFxuXHRcdCAgVGFnVG9rZW4uZm9ybWF0VGFnID0gZnVuY3Rpb24gZm9ybWF0VGFnKHRvaykge1xuXHRcdCAgICB2YXIgY29udGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblx0XG5cdFx0ICAgIHZhciBzdHIgPSAnPCcgKyB0b2sudGFnTmFtZTtcblx0XHQgICAgZm9yICh2YXIga2V5IGluIHRvay5hdHRycykge1xuXHRcdCAgICAgIGlmICh0b2suYXR0cnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdCAgICAgICAgc3RyICs9ICcgJyArIGtleTtcblx0XG5cdFx0ICAgICAgICB2YXIgdmFsID0gdG9rLmF0dHJzW2tleV07XG5cdFx0ICAgICAgICBpZiAodHlwZW9mIHRvay5ib29sZWFuQXR0cnMgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB0b2suYm9vbGVhbkF0dHJzW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0ICAgICAgICAgIHN0ciArPSAnPVwiJyArICgwLCBfdXRpbHMuZXNjYXBlUXVvdGVzKSh2YWwpICsgJ1wiJztcblx0XHQgICAgICAgIH1cblx0XHQgICAgICB9XG5cdFx0ICAgIH1cblx0XG5cdFx0ICAgIGlmICh0b2sucmVzdCkge1xuXHRcdCAgICAgIHN0ciArPSAnICcgKyB0b2sucmVzdDtcblx0XHQgICAgfVxuXHRcblx0XHQgICAgaWYgKHRvay51bmFyeSAmJiAhdG9rLmh0bWw1VW5hcnkpIHtcblx0XHQgICAgICBzdHIgKz0gJy8+Jztcblx0XHQgICAgfSBlbHNlIHtcblx0XHQgICAgICBzdHIgKz0gJz4nO1xuXHRcdCAgICB9XG5cdFxuXHRcdCAgICBpZiAoY29udGVudCAhPT0gdW5kZWZpbmVkICYmIGNvbnRlbnQgIT09IG51bGwpIHtcblx0XHQgICAgICBzdHIgKz0gY29udGVudCArICc8LycgKyB0b2sudGFnTmFtZSArICc+Jztcblx0XHQgICAgfVxuXHRcblx0XHQgICAgcmV0dXJuIHN0cjtcblx0XHQgIH07XG5cdFxuXHRcdCAgcmV0dXJuIFRhZ1Rva2VuO1xuXHRcdH0oKTtcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RhcnRUYWdUb2tlbiByZXByZXNlbnRzIGEgc3RhcnQgdG9rZW4uXG5cdFx0ICovXG5cdFxuXHRcblx0XHR2YXIgU3RhcnRUYWdUb2tlbiA9IGV4cG9ydHMuU3RhcnRUYWdUb2tlbiA9IGZ1bmN0aW9uICgpIHtcblx0XHQgIC8qKlxuXHRcdCAgICogQ29uc3RydWN0b3IuXG5cdFx0ICAgKlxuXHRcdCAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgVGhlIHRhZyBuYW1lLlxuXHRcdCAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBUb2tlbiB0ZXh0XG5cdFx0ICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cnMgVGhlIGRpY3Rpb25hcnkgb2YgYXR0cmlidXRlcyBhbmQgdmFsdWVzXG5cdFx0ICAgKiBAcGFyYW0ge09iamVjdH0gYm9vbGVhbkF0dHJzIElmIGFuIGVudHJ5IGhhcyAndHJ1ZScgdGhlbiB0aGUgYXR0cmlidXRlXG5cdFx0ICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGVcblx0XHQgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdW5hcnkgVHJ1ZSBpZiB0aGUgdGFnIGlzIGEgdW5hcnkgdGFnXG5cdFx0ICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzdCBUaGUgcmVzdCBvZiB0aGUgY29udGVudC5cblx0XHQgICAqL1xuXHRcdCAgZnVuY3Rpb24gU3RhcnRUYWdUb2tlbih0YWdOYW1lLCBsZW5ndGgsIGF0dHJzLCBib29sZWFuQXR0cnMsIHVuYXJ5LCByZXN0KSB7XG5cdFx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGFydFRhZ1Rva2VuKTtcblx0XG5cdFx0ICAgIHRoaXMudHlwZSA9ICdzdGFydFRhZyc7XG5cdFx0ICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuXHRcdCAgICB0aGlzLnRleHQgPSAnJztcblx0XHQgICAgdGhpcy50YWdOYW1lID0gdGFnTmFtZTtcblx0XHQgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuXHRcdCAgICB0aGlzLmJvb2xlYW5BdHRycyA9IGJvb2xlYW5BdHRycztcblx0XHQgICAgdGhpcy5odG1sNVVuYXJ5ID0gZmFsc2U7XG5cdFx0ICAgIHRoaXMudW5hcnkgPSB1bmFyeTtcblx0XHQgICAgdGhpcy5yZXN0ID0gcmVzdDtcblx0XHQgIH1cblx0XG5cdFx0ICBTdGFydFRhZ1Rva2VuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdCAgICByZXR1cm4gVGFnVG9rZW4uZm9ybWF0VGFnKHRoaXMpO1xuXHRcdCAgfTtcblx0XG5cdFx0ICByZXR1cm4gU3RhcnRUYWdUb2tlbjtcblx0XHR9KCk7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEF0b21pY1RhZ1Rva2VuIHJlcHJlc2VudHMgYW4gYXRvbWljIHRhZy5cblx0XHQgKi9cblx0XG5cdFxuXHRcdHZhciBBdG9taWNUYWdUb2tlbiA9IGV4cG9ydHMuQXRvbWljVGFnVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAvKipcblx0XHQgICAqIENvbnN0cnVjdG9yLlxuXHRcdCAgICpcblx0XHQgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIFRoZSBuYW1lIG9mIHRoZSB0YWcuXG5cdFx0ICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIHRhZyB0ZXh0LlxuXHRcdCAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIFRoZSBhdHRyaWJ1dGVzLlxuXHRcdCAgICogQHBhcmFtIHtPYmplY3R9IGJvb2xlYW5BdHRycyBJZiBhbiBlbnRyeSBoYXMgJ3RydWUnIHRoZW4gdGhlIGF0dHJpYnV0ZVxuXHRcdCAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBhIGJvb2xlYW4gYXR0cmlidXRlXG5cdFx0ICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCBUaGUgY29udGVudCBvZiB0aGUgdGFnLlxuXHRcdCAgICovXG5cdFx0ICBmdW5jdGlvbiBBdG9taWNUYWdUb2tlbih0YWdOYW1lLCBsZW5ndGgsIGF0dHJzLCBib29sZWFuQXR0cnMsIGNvbnRlbnQpIHtcblx0XHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF0b21pY1RhZ1Rva2VuKTtcblx0XG5cdFx0ICAgIHRoaXMudHlwZSA9ICdhdG9taWNUYWcnO1xuXHRcdCAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcblx0XHQgICAgdGhpcy50ZXh0ID0gJyc7XG5cdFx0ICAgIHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XG5cdFx0ICAgIHRoaXMuYXR0cnMgPSBhdHRycztcblx0XHQgICAgdGhpcy5ib29sZWFuQXR0cnMgPSBib29sZWFuQXR0cnM7XG5cdFx0ICAgIHRoaXMudW5hcnkgPSBmYWxzZTtcblx0XHQgICAgdGhpcy5odG1sNVVuYXJ5ID0gZmFsc2U7XG5cdFx0ICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG5cdFx0ICB9XG5cdFxuXHRcdCAgQXRvbWljVGFnVG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0ICAgIHJldHVybiBUYWdUb2tlbi5mb3JtYXRUYWcodGhpcywgdGhpcy5jb250ZW50KTtcblx0XHQgIH07XG5cdFxuXHRcdCAgcmV0dXJuIEF0b21pY1RhZ1Rva2VuO1xuXHRcdH0oKTtcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5kVGFnVG9rZW4gcmVwcmVzZW50cyBhbiBlbmQgdGFnLlxuXHRcdCAqL1xuXHRcblx0XG5cdFx0dmFyIEVuZFRhZ1Rva2VuID0gZXhwb3J0cy5FbmRUYWdUb2tlbiA9IGZ1bmN0aW9uICgpIHtcblx0XHQgIC8qKlxuXHRcdCAgICogQ29uc3RydWN0b3IuXG5cdFx0ICAgKlxuXHRcdCAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgVGhlIG5hbWUgb2YgdGhlIHRhZy5cblx0XHQgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgdGFnIHRleHQuXG5cdFx0ICAgKi9cblx0XHQgIGZ1bmN0aW9uIEVuZFRhZ1Rva2VuKHRhZ05hbWUsIGxlbmd0aCkge1xuXHRcdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW5kVGFnVG9rZW4pO1xuXHRcblx0XHQgICAgdGhpcy50eXBlID0gJ2VuZFRhZyc7XG5cdFx0ICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuXHRcdCAgICB0aGlzLnRleHQgPSAnJztcblx0XHQgICAgdGhpcy50YWdOYW1lID0gdGFnTmFtZTtcblx0XHQgIH1cblx0XG5cdFx0ICBFbmRUYWdUb2tlbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHQgICAgcmV0dXJuICc8LycgKyB0aGlzLnRhZ05hbWUgKyAnPic7XG5cdFx0ICB9O1xuXHRcblx0XHQgIHJldHVybiBFbmRUYWdUb2tlbjtcblx0XHR9KCk7XG5cdFxuXHQvKioqLyB9LFxuXHQvKiA1ICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcblx0XHQndXNlIHN0cmljdCc7XG5cdFxuXHRcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdFx0ZXhwb3J0cy5lc2NhcGVRdW90ZXMgPSBlc2NhcGVRdW90ZXM7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVzY2FwZSBxdW90ZXMgaW4gdGhlIGdpdmVuIHZhbHVlLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBlc2NhcGUuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFtkZWZhdWx0VmFsdWU9JyddIFRoZSBkZWZhdWx0IHZhbHVlIHRvIHJldHVybiBpZiB2YWx1ZSBpcyBmYWxzeS5cblx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGVzY2FwZVF1b3Rlcyh2YWx1ZSkge1xuXHRcdCAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG5cdFxuXHRcdCAgLy8gVGhlcmUncyBubyBsb29rYmFjayBpbiBKUywgc28gLyhefFteXFxcXF0pXCIvIG9ubHkgbWF0Y2hlcyB0aGUgZmlyc3Qgb2YgdHdvIGBcImBzLlxuXHRcdCAgLy8gSW5zdGVhZCwganVzdCBtYXRjaCBhbnl0aGluZyBiZWZvcmUgYSBkb3VibGUtcXVvdGUgYW5kIGVzY2FwZSBpZiBpdCdzIG5vdCBhbHJlYWR5IGVzY2FwZWQuXG5cdFx0ICByZXR1cm4gIXZhbHVlID8gZGVmYXVsdFZhbHVlIDogdmFsdWUucmVwbGFjZSgvKFteXCJdKilcIi9nLCBmdW5jdGlvbiAoXywgcHJlZml4KSB7XG5cdFx0ICAgIHJldHVybiAoL1xcXFwvLnRlc3QocHJlZml4KSA/IHByZWZpeCArICdcIicgOiBwcmVmaXggKyAnXFxcXFwiJ1xuXHRcdCAgICApO1xuXHRcdCAgfSk7XG5cdFx0fVxuXHRcblx0LyoqKi8gfSxcblx0LyogNiAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0J3VzZSBzdHJpY3QnO1xuXHRcblx0XHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRcdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZpeGVkUmVhZFRva2VuRmFjdG9yeTtcblx0XHQvKipcblx0XHQgKiBFbXB0eSBFbGVtZW50cyAtIEhUTUwgNC4wMVxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1JlZ0V4cH1cblx0XHQgKi9cblx0XHR2YXIgRU1QVFkgPSAvXihBUkVBfEJBU0V8QkFTRUZPTlR8QlJ8Q09MfEZSQU1FfEhSfElNR3xJTlBVVHxJU0lOREVYfExJTkt8TUVUQXxQQVJBTXxFTUJFRCkkL2k7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVsZW1lbnRzIHRoYXQgeW91IGNhbiBpbnRlbnRpb25hbGx5IGxlYXZlIG9wZW4gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1JlZ0V4cH1cblx0XHQgKi9cblx0XHR2YXIgQ0xPU0VTRUxGID0gL14oQ09MR1JPVVB8RER8RFR8TEl8T1BUSU9OU3xQfFREfFRGT09UfFRIfFRIRUFEfFRSKSQvaTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQ29ycmVjdHMgYSB0b2tlbi5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7VG9rZW59IHRvayBUaGUgdG9rZW4gdG8gY29ycmVjdFxuXHRcdCAqIEByZXR1cm5zIHtUb2tlbn0gVGhlIGNvcnJlY3RlZCB0b2tlblxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGNvcnJlY3QodG9rKSB7XG5cdFx0ICBpZiAodG9rICYmIHRvay50eXBlID09PSAnc3RhcnRUYWcnKSB7XG5cdFx0ICAgIHRvay51bmFyeSA9IEVNUFRZLnRlc3QodG9rLnRhZ05hbWUpIHx8IHRvay51bmFyeTtcblx0XHQgICAgdG9rLmh0bWw1VW5hcnkgPSAhL1xcLz4kLy50ZXN0KHRvay50ZXh0KTtcblx0XHQgIH1cblx0XHQgIHJldHVybiB0b2s7XG5cdFx0fVxuXHRcblx0XHQvKipcblx0XHQgKiBQZWVrcyBhdCB0aGUgbmV4dCB0b2tlbiBpbiB0aGUgcGFyc2VyLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtIdG1sUGFyc2VyfSBwYXJzZXIgVGhlIHBhcnNlclxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IHJlYWRUb2tlbkltcGwgVGhlIHVuZGVybHlpbmcgcmVhZFRva2VuIGltcGxlbWVudGF0aW9uXG5cdFx0ICogQHJldHVybnMge1Rva2VufSBUaGUgbmV4dCB0b2tlblxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHBlZWtUb2tlbihwYXJzZXIsIHJlYWRUb2tlbkltcGwpIHtcblx0XHQgIHZhciB0bXAgPSBwYXJzZXIuc3RyZWFtO1xuXHRcdCAgdmFyIHRvayA9IGNvcnJlY3QocmVhZFRva2VuSW1wbCgpKTtcblx0XHQgIHBhcnNlci5zdHJlYW0gPSB0bXA7XG5cdFx0ICByZXR1cm4gdG9rO1xuXHRcdH1cblx0XG5cdFx0LyoqXG5cdFx0ICogQ2xvc2VzIHRoZSBsYXN0IHRva2VuLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtIdG1sUGFyc2VyfSBwYXJzZXIgVGhlIHBhcnNlclxuXHRcdCAqIEBwYXJhbSB7QXJyYXk8VG9rZW4+fSBzdGFjayBUaGUgc3RhY2tcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBjbG9zZUxhc3QocGFyc2VyLCBzdGFjaykge1xuXHRcdCAgdmFyIHRvayA9IHN0YWNrLnBvcCgpO1xuXHRcblx0XHQgIC8vIHByZXBlbmQgY2xvc2UgdGFnIHRvIHN0cmVhbS5cblx0XHQgIHBhcnNlci5wcmVwZW5kKCc8LycgKyB0b2sudGFnTmFtZSArICc+Jyk7XG5cdFx0fVxuXHRcblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYSBuZXcgdG9rZW4gc3RhY2suXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7QXJyYXk8VG9rZW4+fVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIG5ld1N0YWNrKCkge1xuXHRcdCAgdmFyIHN0YWNrID0gW107XG5cdFxuXHRcdCAgc3RhY2subGFzdCA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgcmV0dXJuIHRoaXNbdGhpcy5sZW5ndGggLSAxXTtcblx0XHQgIH07XG5cdFxuXHRcdCAgc3RhY2subGFzdFRhZ05hbWVFcSA9IGZ1bmN0aW9uICh0YWdOYW1lKSB7XG5cdFx0ICAgIHZhciBsYXN0ID0gdGhpcy5sYXN0KCk7XG5cdFx0ICAgIHJldHVybiBsYXN0ICYmIGxhc3QudGFnTmFtZSAmJiBsYXN0LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gdGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuXHRcdCAgfTtcblx0XG5cdFx0ICBzdGFjay5jb250YWluc1RhZ05hbWUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuXHRcdCAgICBmb3IgKHZhciBpID0gMCwgdG9rOyB0b2sgPSB0aGlzW2ldOyBpKyspIHtcblx0XHQgICAgICBpZiAodG9rLnRhZ05hbWUgPT09IHRhZ05hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICB9O1xuXHRcblx0XHQgIHJldHVybiBzdGFjaztcblx0XHR9XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiBhIHJlYWRUb2tlbiBpbXBsZW1lbnRhdGlvbiB0aGF0IGZpeGVzIGlucHV0LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtIdG1sUGFyc2VyfSBwYXJzZXIgVGhlIHBhcnNlclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgZm9yIGZpeGluZ1xuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy50YWdTb3VwRml4IFRydWUgdG8gZml4IHRhZyBzb3VwIHNjZW5hcmlvc1xuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZWxmQ2xvc2VGaXggVHJ1ZSB0byBmaXggc2VsZi1jbG9zaW5nIHRhZ3Ncblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWFkVG9rZW5JbXBsIFRoZSB1bmRlcmx5aW5nIHJlYWRUb2tlbiBpbXBsZW1lbnRhdGlvblxuXHRcdCAqIEByZXR1cm5zIHtGdW5jdGlvbn1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBmaXhlZFJlYWRUb2tlbkZhY3RvcnkocGFyc2VyLCBvcHRpb25zLCByZWFkVG9rZW5JbXBsKSB7XG5cdFx0ICB2YXIgc3RhY2sgPSBuZXdTdGFjaygpO1xuXHRcblx0XHQgIHZhciBoYW5kbGVycyA9IHtcblx0XHQgICAgc3RhcnRUYWc6IGZ1bmN0aW9uIHN0YXJ0VGFnKHRvaykge1xuXHRcdCAgICAgIHZhciB0YWdOYW1lID0gdG9rLnRhZ05hbWU7XG5cdFxuXHRcdCAgICAgIGlmICh0YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdUUicgJiYgc3RhY2subGFzdFRhZ05hbWVFcSgnVEFCTEUnKSkge1xuXHRcdCAgICAgICAgcGFyc2VyLnByZXBlbmQoJzxUQk9EWT4nKTtcblx0XHQgICAgICAgIHByZXBhcmVOZXh0VG9rZW4oKTtcblx0XHQgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2VsZkNsb3NlRml4ICYmIENMT1NFU0VMRi50ZXN0KHRhZ05hbWUpICYmIHN0YWNrLmNvbnRhaW5zVGFnTmFtZSh0YWdOYW1lKSkge1xuXHRcdCAgICAgICAgaWYgKHN0YWNrLmxhc3RUYWdOYW1lRXEodGFnTmFtZSkpIHtcblx0XHQgICAgICAgICAgY2xvc2VMYXN0KHBhcnNlciwgc3RhY2spO1xuXHRcdCAgICAgICAgfSBlbHNlIHtcblx0XHQgICAgICAgICAgcGFyc2VyLnByZXBlbmQoJzwvJyArIHRvay50YWdOYW1lICsgJz4nKTtcblx0XHQgICAgICAgICAgcHJlcGFyZU5leHRUb2tlbigpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgIH0gZWxzZSBpZiAoIXRvay51bmFyeSkge1xuXHRcdCAgICAgICAgc3RhY2sucHVzaCh0b2spO1xuXHRcdCAgICAgIH1cblx0XHQgICAgfSxcblx0XHQgICAgZW5kVGFnOiBmdW5jdGlvbiBlbmRUYWcodG9rKSB7XG5cdFx0ICAgICAgdmFyIGxhc3QgPSBzdGFjay5sYXN0KCk7XG5cdFx0ICAgICAgaWYgKGxhc3QpIHtcblx0XHQgICAgICAgIGlmIChvcHRpb25zLnRhZ1NvdXBGaXggJiYgIXN0YWNrLmxhc3RUYWdOYW1lRXEodG9rLnRhZ05hbWUpKSB7XG5cdFx0ICAgICAgICAgIC8vIGNsZWFudXAgdGFnIHNvdXBcblx0XHQgICAgICAgICAgY2xvc2VMYXN0KHBhcnNlciwgc3RhY2spO1xuXHRcdCAgICAgICAgfSBlbHNlIHtcblx0XHQgICAgICAgICAgc3RhY2sucG9wKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnRhZ1NvdXBGaXgpIHtcblx0XHQgICAgICAgIC8vIGNsZWFudXAgdGFnIHNvdXAgcGFydCAyOiBza2lwIHRoaXMgdG9rZW5cblx0XHQgICAgICAgIHJlYWRUb2tlbkltcGwoKTtcblx0XHQgICAgICAgIHByZXBhcmVOZXh0VG9rZW4oKTtcblx0XHQgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgIH07XG5cdFxuXHRcdCAgZnVuY3Rpb24gcHJlcGFyZU5leHRUb2tlbigpIHtcblx0XHQgICAgdmFyIHRvayA9IHBlZWtUb2tlbihwYXJzZXIsIHJlYWRUb2tlbkltcGwpO1xuXHRcdCAgICBpZiAodG9rICYmIGhhbmRsZXJzW3Rvay50eXBlXSkge1xuXHRcdCAgICAgIGhhbmRsZXJzW3Rvay50eXBlXSh0b2spO1xuXHRcdCAgICB9XG5cdFx0ICB9XG5cdFxuXHRcdCAgcmV0dXJuIGZ1bmN0aW9uIGZpeGVkUmVhZFRva2VuKCkge1xuXHRcdCAgICBwcmVwYXJlTmV4dFRva2VuKCk7XG5cdFx0ICAgIHJldHVybiBjb3JyZWN0KHJlYWRUb2tlbkltcGwoKSk7XG5cdFx0ICB9O1xuXHRcdH1cblx0XG5cdC8qKiovIH1cblx0LyoqKioqKi8gXSlcblx0fSk7XG5cdDtcblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdFxuXHR2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cdFxuXHRleHBvcnRzLmV4aXN0eSA9IGV4aXN0eTtcblx0ZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblx0ZXhwb3J0cy5lYWNoID0gZWFjaDtcblx0ZXhwb3J0cy5lYWNoS2V5ID0gZWFjaEtleTtcblx0ZXhwb3J0cy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuXHRleHBvcnRzLnRvQXJyYXkgPSB0b0FycmF5O1xuXHRleHBvcnRzLmxhc3QgPSBsYXN0O1xuXHRleHBvcnRzLmlzVGFnID0gaXNUYWc7XG5cdGV4cG9ydHMuaXNTY3JpcHQgPSBpc1NjcmlwdDtcblx0ZXhwb3J0cy5pc1N0eWxlID0gaXNTdHlsZTtcblx0LyoqXG5cdCAqIERldGVybWluZSBpZiB0aGUgdGhpbmcgaXMgbm90IHVuZGVmaW5lZCBhbmQgbm90IG51bGwuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0gdGhpbmcgVGhlIHRoaW5nIHRvIHRlc3Rcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHRoaW5nIGlzIG5vdCB1bmRlZmluZWQgYW5kIG5vdCBudWxsLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXhpc3R5KHRoaW5nKSB7XG5cdCAgcmV0dXJuIHRoaW5nICE9PSB2b2lkIDAgJiYgdGhpbmcgIT09IG51bGw7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBJcyB0aGlzIGEgZnVuY3Rpb24/XG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0geCBUaGUgdmFyaWFibGUgdG8gdGVzdFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFyaWFibGUgaXMgYSBmdW5jdGlvblxuXHQgKi9cblx0ZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG5cdCAgcmV0dXJuICdmdW5jdGlvbicgPT09IHR5cGVvZiB4O1xuXHR9XG5cdFxuXHQvKipcblx0ICogTG9vcCBvdmVyIGVhY2ggaXRlbSBpbiBhbiBhcnJheS1saWtlIHZhbHVlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PCo+fSBhcnIgVGhlIGFycmF5IHRvIGxvb3Agb3ZlclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbFxuXHQgKiBAcGFyYW0gez9PYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRvIGJpbmQgdG8gdGhlIGZ1bmN0aW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBlYWNoKGFyciwgZm4sIHRhcmdldCkge1xuXHQgIHZhciBpID0gdm9pZCAwO1xuXHQgIHZhciBsZW4gPSBhcnIgJiYgYXJyLmxlbmd0aCB8fCAwO1xuXHQgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHQgICAgZm4uY2FsbCh0YXJnZXQsIGFycltpXSwgaSk7XG5cdCAgfVxuXHR9XG5cdFxuXHQvKipcblx0ICogTG9vcCBvdmVyIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gYSBoYXNoLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3Rcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGxcblx0ICogQHBhcmFtIHs/T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0byBiaW5kIHRvIHRoZSBmdW5jdGlvblxuXHQgKi9cblx0ZnVuY3Rpb24gZWFjaEtleShvYmosIGZuLCB0YXJnZXQpIHtcblx0ICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdCAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0ICAgICAgZm4uY2FsbCh0YXJnZXQsIGtleSwgb2JqW2tleV0pO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIFNldCBkZWZhdWx0IG9wdGlvbnMgd2hlcmUgc29tZSBvcHRpb24gd2FzIG5vdCBzcGVjaWZpZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBkZXN0aW5hdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gX2RlZmF1bHRzIFRoZSBkZWZhdWx0c1xuXHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHQgKi9cblx0ZnVuY3Rpb24gZGVmYXVsdHMob3B0aW9ucywgX2RlZmF1bHRzKSB7XG5cdCAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdCAgZWFjaEtleShfZGVmYXVsdHMsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuXHQgICAgaWYgKCFleGlzdHkob3B0aW9uc1trZXldKSkge1xuXHQgICAgICBvcHRpb25zW2tleV0gPSB2YWw7XG5cdCAgICB9XG5cdCAgfSk7XG5cdCAgcmV0dXJuIG9wdGlvbnM7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDb252ZXJ0IHZhbHVlIChlLmcuLCBhIE5vZGVMaXN0KSB0byBhbiBhcnJheS5cblx0ICpcblx0ICogQHBhcmFtIHsqfSBvYmogVGhlIG9iamVjdFxuXHQgKiBAcmV0dXJucyB7QXJyYXk8Kj59XG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FycmF5KG9iaikge1xuXHQgIHRyeSB7XG5cdCAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKTtcblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIHJldCA9IFtdO1xuXHQgICAgICBlYWNoKG9iaiwgZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgIHJldC5wdXNoKHZhbCk7XG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIHY6IHJldFxuXHQgICAgICB9O1xuXHQgICAgfSgpO1xuXHRcblx0ICAgIGlmICgodHlwZW9mIF9yZXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKF9yZXQpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcblx0ICB9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIGxhc3QgaXRlbSBpbiBhbiBhcnJheVxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PCo+fSBhcnJheSBUaGUgYXJyYXlcblx0ICogQHJldHVybnMgeyp9IFRoZSBsYXN0IGl0ZW0gaW4gdGhlIGFycmF5XG5cdCAqL1xuXHRmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG5cdCAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuXHR9XG5cdFxuXHQvKipcblx0ICogVGVzdCBpZiB0b2tlbiBpcyBhIHNjcmlwdCB0YWcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0b2sgVGhlIHRva2VuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0YWcgVGhlIHRhZyBuYW1lXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB0b2tlbiBpcyBhIHNjcmlwdCB0YWdcblx0ICovXG5cdGZ1bmN0aW9uIGlzVGFnKHRvaywgdGFnKSB7XG5cdCAgcmV0dXJuICF0b2sgfHwgISh0b2sudHlwZSA9PT0gJ3N0YXJ0VGFnJyB8fCB0b2sudHlwZSA9PT0gJ2F0b21pY1RhZycpIHx8ICEoJ3RhZ05hbWUnIGluIHRvaykgPyAhMSA6ICEhfnRvay50YWdOYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0YWcpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogVGVzdCBpZiB0b2tlbiBpcyBhIHNjcmlwdCB0YWcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0b2sgVGhlIHRva2VuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB0b2tlbiBpcyBhIHNjcmlwdCB0YWdcblx0ICovXG5cdGZ1bmN0aW9uIGlzU2NyaXB0KHRvaykge1xuXHQgIHJldHVybiBpc1RhZyh0b2ssICdzY3JpcHQnKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFRlc3QgaWYgdG9rZW4gaXMgYSBzdHlsZSB0YWcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0b2sgVGhlIHRva2VuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB0b2tlbiBpcyBhIHN0eWxlIHRhZ1xuXHQgKi9cblx0ZnVuY3Rpb24gaXNTdHlsZSh0b2spIHtcblx0ICByZXR1cm4gaXNUYWcodG9rLCAnc3R5bGUnKTtcblx0fVxuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3N0c2NyaWJlLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postscribe/dist/postscribe.js\n");

/***/ })

}]);